<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Windows远程桌面连接</title>
    <link href="/2025/03/18/Windows%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5/"/>
    <url>/2025/03/18/Windows%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="一、查询要连接的电脑IP"><a href="#一、查询要连接的电脑IP" class="headerlink" title="一、查询要连接的电脑IP"></a>一、查询要连接的电脑IP</h2><p>按下win+R打开控制终端，输入下列指令：  </p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">ipconfig</span><br></code></pre></td></tr></table></figure><p>找到 IPv4 地址，如 192.168.1.100。<br>注意：连接WIFI和接入网线两种情况的IP不同哦。</p><h2 id="二、查询本机用户名"><a href="#二、查询本机用户名" class="headerlink" title="二、查询本机用户名"></a>二、查询本机用户名</h2><ol><li>输入下列命令即可查询到本机用户名： <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">net <span class="hljs-keyword">user</span><br></code></pre></td></tr></table></figure></li><li>方法二：输入以下命令并回车：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">whoami</span><br></code></pre></td></tr></table></figure>终端将返回类似于：DESKTOP-123ABC\admin ，其中”admin”就是远程用户名，而 DESKTOP-123ABC 是计算机名。</li></ol><h2 id="三、确认本机密码"><a href="#三、确认本机密码" class="headerlink" title="三、确认本机密码"></a>三、确认本机密码</h2><p>Win + R，输入下列命令并回车：  </p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lsl"><span class="hljs-section">control</span> userpasswords2<br></code></pre></td></tr></table></figure><p>在弹出的窗口中，你会看到本机所有账户，带有“管理员”权限的账户通常是你要远程登录的账户。<br>记住这个用户名，它就是你远程连接时要输入的。<br>这里查询到的用户信息对应的密码就是远程登陆密码 —— 比如我查询到的账户是我的微软邮箱，那么就应该对应输入我的微软邮箱密码。<br>若查询到的账户是本地账户，那就可以输入PIN连接。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>新遇见的C库函数</title>
    <link href="/2025/03/04/%E6%96%B0%E9%81%87%E8%A7%81%E7%9A%84C%E5%BA%93%E5%87%BD%E6%95%B0/"/>
    <url>/2025/03/04/%E6%96%B0%E9%81%87%E8%A7%81%E7%9A%84C%E5%BA%93%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="C库函数"><a href="#C库函数" class="headerlink" title="C库函数"></a>C库函数</h1><h2 id="一、分割字符串函数"><a href="#一、分割字符串函数" class="headerlink" title="一、分割字符串函数"></a>一、分割字符串函数</h2><h3 id="1-strtok-——-线程不安全"><a href="#1-strtok-——-线程不安全" class="headerlink" title="1. strtok() —— 线程不安全"></a>1. strtok() —— 线程不安全</h3><h4 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//strtok()函数原型</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">strtok</span><span class="hljs-params">(<span class="hljs-type">char</span> *str, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *delim)</span></span><br></code></pre></td></tr></table></figure><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><p>strtok 函数用于将字符串分割成一系列的标记（tokens）。  </p><h4 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h4><ul><li><strong>str：</strong> 指向要被分割的字符串。在第一次调用时，应传入待分割的字符串；在后续调用中，应传入 NULL 以继续分割剩余的字符串。  </li><li><strong>delim：</strong> 指向包含分隔符的字符串。这些字符将作为标记的分隔符。</li></ul><h4 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h4><p>该函数返回被分解的第一个子字符串，如果没有可检索的字符串，则返回一个空指针。</p><h4 id="使用注意事项："><a href="#使用注意事项：" class="headerlink" title="使用注意事项："></a>使用注意事项：</h4><p>strtok 函数使用静态变量来存储分割过程的上下文信息，因此在多线程环境中是不安全的。<br>每次调用 strtok 后，str 中的分隔符会被替换为字符串终止符 ‘\0’，从而分割出一个个标记。<br>由于 strtok 使用静态变量，因此在连续调用时不需要传递额外的参数来保存上下文信息。<br>使用示例：<br><img src="/../img/functionsOfC/strtok_Sample.png" alt="strtok函数使用实例">  </p><h4 id="注意事项验证："><a href="#注意事项验证：" class="headerlink" title="注意事项验证："></a>注意事项验证：</h4><p>每次调用 strtok 后，str 中的分隔符会被替换为字符串终止符 ‘\0’，从而分割出一个个标记。<br>因此在调用一次若成功分割出字符串后，str中的分隔符被替换为字符串终止符 ‘\0’，之后再打印字符串str，该字符串内容就会在’\0’的位置结束，即成为第一个分割出的子字符串。  </p><h4 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h4><p>strtok函数在切割字符串的过程，实际上就是将被分割的字符串的分隔字符替换为‘\0’ 并且返回每次的标记字符串的首地址，直到返回NULL结束。<br><img src="/../img/functionsOfC/strtok_Analyze.png" alt="strtok函数分析"> </p><h3 id="2-strtok-r-——-线程安全"><a href="#2-strtok-r-——-线程安全" class="headerlink" title="2. strtok_r() —— 线程安全"></a>2. strtok_r() —— 线程安全</h3><p>strtok_r是一个c语言库函数，定义在&lt;string.h&gt;头文件中，用于字符串分割，是 strtok 函数的线程安全版本。</p><h4 id="函数原型：-1"><a href="#函数原型：-1" class="headerlink" title="函数原型："></a>函数原型：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//函数原型</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">strtok_r</span><span class="hljs-params">(<span class="hljs-type">char</span> *str, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *delim, <span class="hljs-type">char</span> **saveptr)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="作用：-1"><a href="#作用：-1" class="headerlink" title="作用："></a>作用：</h4><p>strtok_r 函数用于将字符串分割成一系列的标记（tokens），它是 strtok 函数的线程安全版本。<br>在多线程环境中，由于 strtok 函数使用静态变量来存储上下文信息，可能会导致数据竞争和不安全的行为。而 strtok_r 通过提供一个额外的参数 saveptr 来存储这个上下文信息，从而避免了这些问题。  </p><h4 id="参数说明：-1"><a href="#参数说明：-1" class="headerlink" title="参数说明："></a>参数说明：</h4><ul><li><strong>str：</strong> 指向要被分割的字符串。在第一次调用时，应传入待分割的字符串；在后续调用中，应传入 NULL 以继续分割剩余的字符串。</li><li><strong>delim：</strong> 指向包含分隔符的字符串。这些字符将作为标记的分隔符。</li><li><strong>saveptr：</strong> 指向 char * 类型的变量，用于存储分割过程的上下文信息。在第一次调用时，可以传入一个未初始化的指针变量；在后续调用中，应传入上次调用后返回的 saveptr 的值。返回值：<br>遇到第一个delim时，返回前面成功分割出的字符串；若一直没有遇到delim，则返回NULL。</li></ul><h4 id="安全性："><a href="#安全性：" class="headerlink" title="安全性："></a>安全性：</h4><p>（1）该函数也会破坏待分解字符串的完整性，但是其将剩余的字符串保存在saveptr变量中，保证了安全性。<br>（2）在函数 strtok 中剩余字符串是存储在一个静态变量中，因此，多线程在使用该静态变量时引起冲突；而 strtok_r 则使用用户传入的指针为每个用户saveptr重新申请变量，因而可以保证线程安全。  </p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p><strong>参数初始化</strong>   </p><ul><li>首次调用：str 参数必须指向待分割的字符串首地址。  </li><li>后续调用：str 参数需设为 NULL，函数会自动从上次分割结束的位置继续处理。</li></ul><p><strong>上下文保存 (saveptr)</strong>  </p><ul><li>saveptr 是函数内部用于记录分割位置的指针，调用者需为其分配内存并传入地址。  </li><li>同一字符串的连续调用中，必须传递同一个 saveptr（函数会修改其内容）。  </li><li>禁止手动修改 saveptr 指向的值，否则可能导致不可预测的分割结果。</li></ul><p><strong>字符串修改行为</strong>  </p><ul><li>每次调用后，函数会将当前分割位置的分隔符替换为 \0，使返回的指针指向一个独立子字符串。  </li><li>原始字符串会被破坏，若需保留原数据，应在调用前复制副本。</li></ul><p><strong>返回值</strong>  </p><ul><li>成功分割时返回当前子字符串的指针。  </li><li>无更多子字符串时返回 NULL。</li></ul><p><strong>多字符串并发处理</strong>     </p><ul><li>若需同时分割多个独立字符串，必须为每个字符串分配不同的 saveptr 变量，避免上下文冲突。</li></ul><h2 id="二、可重入函数与不可重入函数"><a href="#二、可重入函数与不可重入函数" class="headerlink" title="二、可重入函数与不可重入函数"></a>二、可重入函数与不可重入函数</h2><h3 id="可重入函数："><a href="#可重入函数：" class="headerlink" title="可重入函数："></a>可重入函数：</h3><p>（1）重入即表示重复进入，首先它意味着这个函数可以被中断，其次意味着它除了使用自己栈上的变量以外不依赖于任何环境（包括static），这样的函数就是purecode（纯代码）可重入，可以允许有该函数的多个副本在运行，由于它们使用的是分离的栈，所以不会互相干扰。如果确实需要访问全局变量（包括static），一定要注意实施互斥手段。可重入函数在并行运行环境中非常重要，但是一般要为访问全局变量付出一些性能代价。    </p><p>（2）指一个可以被多个任务调用的函数（过程），任务在调用时不必担心数据是否会出错。  </p><h3 id="不可重入函数："><a href="#不可重入函数：" class="headerlink" title="不可重入函数："></a>不可重入函数：</h3><p>  如果函数接口的代码实现中在块内定义和使用了static存储类型的变量，这种函数将是不可重入函数。它在实时系统中是不安全函数。  </p><h2 id="三、strcspn-函数"><a href="#三、strcspn-函数" class="headerlink" title="三、strcspn 函数"></a>三、strcspn 函数</h2><h3 id="函数原型：-2"><a href="#函数原型：-2" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">strcspn</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *sl,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s2)</span></span><br></code></pre></td></tr></table></figure><h3 id="作用：-2"><a href="#作用：-2" class="headerlink" title="作用："></a>作用：</h3><p>该函数计算参数s1指向字符串中最大初始片段的长度，且该片段不包含参数s2指向的字符串中的字符。</p><h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3><p>const char *s1: 指向字符串的指针。<br>const char *s2: 指向字符串的指针。</p><h3 id="返回值：-1"><a href="#返回值：-1" class="headerlink" title="返回值："></a>返回值：</h3><p>函数返回最大初始片段的长度。</p><h3 id="使用示例："><a href="#使用示例：" class="headerlink" title="使用示例："></a>使用示例：</h3><p><img src="/../img/functionsOfC/strcspnUse.png" alt="strcspn函数使用实例"> </p><h2 id="四、strtol与strtoul函数"><a href="#四、strtol与strtoul函数" class="headerlink" title="四、strtol与strtoul函数"></a>四、strtol与strtoul函数</h2><h3 id="1-strol"><a href="#1-strol" class="headerlink" title="1. strol"></a>1. strol</h3><h4 id="函数原型：-3"><a href="#函数原型：-3" class="headerlink" title="函数原型："></a>函数原型：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//将字符串转换成长整型数(long)</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title">strtol</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str, <span class="hljs-type">char</span> **endptr, <span class="hljs-type">int</span> base)</span></span><br></code></pre></td></tr></table></figure><h4 id="作用：-3"><a href="#作用：-3" class="headerlink" title="作用："></a>作用：</h4><p>strtol是一个C 库函数，可以<strong>把</strong>参数 str 所指向的<strong>字符串</strong>根据给定的 base 转换基数<strong>转换为一个长整数</strong>（long int 型）。</p><h4 id="参数说明：-2"><a href="#参数说明：-2" class="headerlink" title="参数说明："></a>参数说明：</h4><ul><li><strong>str</strong> – 需要被转换为长整数的字符串。</li><li><strong>endptr</strong> – 第一个不能转换的字符的指针(为NULL时，表示参数无效)。</li><li><strong>base</strong> – 转换基数，必须是 [ 2 , 36 ] 区间的值，或者是特殊值 0。（例如，10 表示十进制，16 表示十六进制。当 base 为 0 时，函数会自动检测字符串的格式：如果以 “0x” 或 “0X” 开头，则按十六进制解析；如果以 “0” 开头（但不是 “0x” 或 “0X”），则按八进制解析；否则，按十进制解析。）</li></ul><h4 id="返回值：-2"><a href="#返回值：-2" class="headerlink" title="返回值："></a>返回值：</h4><ul><li>若 成功，返回转换后的长整型数。</li><li>若 不能转换 或 str 为空字符串 ，那么返回 0(0L)；</li><li>若 转换得到的值超出 long int 所能表示的范围 ，函数将返回 LONG_MAX 或 LONG_MIN（在 limits.h 头文件中定义）， 并将 errno 的值设置为 ERANGE。</li></ul><p><img src="/../img/functionsOfC/strtol.png" alt="strtol函数"> </p><h2 id="2-stroul"><a href="#2-stroul" class="headerlink" title="2. stroul"></a>2. stroul</h2><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//将字符串转换成无符号长整型数(unsigned long)</span><br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title">strtoul</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str, <span class="hljs-type">char</span>** endptr, <span class="hljs-type">int</span> base)</span></span>; <br></code></pre></td></tr></table></figure><p><img src="/../img/functionsOfC/strtoul.png" alt="strtoul函数"> </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>虚拟地址和物理地址的关系</title>
    <link href="/2025/03/04/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <url>/2025/03/04/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="虚拟地址和物理地址的关系"><a href="#虚拟地址和物理地址的关系" class="headerlink" title="虚拟地址和物理地址的关系"></a>虚拟地址和物理地址的关系</h1><h2 id="一、分页："><a href="#一、分页：" class="headerlink" title="一、分页："></a>一、分页：</h2><p>即把整个虚拟和物理内存切成一段段固定大小的空间，连续且尺寸固定的内存空间叫页，Linux下每一页大小4KB。<br>虚拟内存和物理内存之间通过页表来映射；<br>虚拟地址分为：页号和页内偏移。<br>页号作为页表的索引，页表包含物理页每页所在物理内存的基地址，这个基地址与页内偏移的组合就形成了物理内存地址。<br><img src="/../img/virtualANDphysics/virtual2phy.png" alt="虚拟地址转为物理地址"></p><h3 id="简单分页缺点"><a href="#简单分页缺点" class="headerlink" title="简单分页缺点"></a>简单分页缺点</h3><p><strong>空间上的缺陷：</strong><br>32位的内存地址空间，单进程有虚拟内存4GB，一个页表项4B，结果是4GB空间映射就需要4*2^20 &#x3D; 4MB来存储页表。   </p><p>但每一个进程都有属于自己独立的虚拟内存地址空间。这也意味着，每一个进程都需要这样一个页表。不管我们这个进程，是个本身只有几 KB 大小的程序，还是需要几 GB 的内存空间，都需要这样一个页表。若多进程100，则需要400MB。  </p><h2 id="二、多级页表"><a href="#二、多级页表" class="headerlink" title="二、多级页表"></a>二、多级页表</h2><h3 id="以4级页表为例理解多级页表"><a href="#以4级页表为例理解多级页表" class="headerlink" title="以4级页表为例理解多级页表"></a>以4级页表为例理解多级页表</h3><p>同样一个虚拟内存地址，偏移量的部分和上面简单页表一样不变，但是原先的页号部分，我们把它拆成四段，从高到低，分成 4 级到1 级这样 4 个页表索引。</p><p>对应的，一个进程会有一个 4 级页表。    </p><p>首先通过 4 级页表索引，找到 4 级页表里面对应的4级条目，里面对应存放的内容是一张 3 级页表所在的位置（4 级页面里面的每一个条目，都对应着一张 3 级页表，所以我们可能有多张 3 级页表）。   </p><p>找到对应的那张 3 级页表之后，继续根据 3 级索引去找到对应的 3 级条目。3 级索引的条目再会指向一个 2 级页表。同样的，2 级页表里我们可以用 2 级索引指向一个 1 级页表。    </p><p>而最后一层的 1 级页表里面的条目，对应存放的数据内容就是物理页号了。在拿到物理页号之后，我们同样可以用“页号 + 偏移量”的方式，来获取最终的物理内存地址。    </p><p>我们可能有很多张 1 级页表、2 级页表，乃至 3 级页表。但是，因为实际的虚拟内存空间通常是连续的，我们很可能只需要很少的 2 级页表，甚至只需要 1 张 3 级页表就够了。<br><img src="/../img/virtualANDphysics/fourLevelPage.png" alt="4级页表">     </p><p>以这样的分成 4 级的多级页表来看，每一级的索引我们如果都用 5 bit表示。那么每一张某级的页表，均只需要 2^5&#x3D;32 个条目。如果每个条目还是 4 个字节，那么每张页表需要32*4 B&#x3D; 128 个字节。<br>而最后的物理地址页表，对应2^12个条目（页表项）。一个填满的 1 级页表，对应的就是 32 个 物理地址页表，也就对应32 * 2^12 &#x3D; 128K个页表项。  </p><h2 id="三、多级页表查找方式"><a href="#三、多级页表查找方式" class="headerlink" title="三、多级页表查找方式"></a>三、多级页表查找方式</h2><p>多级页表结构分为PGD&#x2F;PUD&#x2F;PMD&#x2F;PTE这几个层级，PTE是页表项。他们之间的关系是层级结构，通过PGD访问到最低端的PTE，访问方式是上一层地址+偏移(offset)。<br>PTE+页内偏移量可以访问到具体的物理地址。<br><img src="/../img/virtualANDphysics/pageStruct.png" alt="多级页表结构">   </p><h3 id="查找过程描述如下："><a href="#查找过程描述如下：" class="headerlink" title="查找过程描述如下："></a>查找过程描述如下：</h3><ol><li>把 TTBR + PGD index 对应的地址读回来，这一个单元内包含了<strong>PUD的基地址</strong>    </li><li>把 PUD baseAddr + PUD index 对应的地址读回来，这一个单元包含了<strong>PMD的基地址</strong>  </li><li>把 PMD baseAddr+PMD index 对应的地址读回来，这一个单元包含了<strong>PTE的基地址</strong>  </li><li>把 PTE baseAddr+PTE index 对应的地址读回来，这一个单元包含了<strong>最终的VA-PA的映射entry</strong></li></ol><p>可以看到 TTBR&#x2F;PGD&#x2F;PUD&#x2F;PMD <strong>存储的都是下一级页表的地址，和VA&#x2F;PA没有直接关系</strong> 。就像C语言里面的指针和指针指向地址的内容一样。  </p><h2 id="四、多级页表的优点及其原因"><a href="#四、多级页表的优点及其原因" class="headerlink" title="四、多级页表的优点及其原因"></a>四、多级页表的优点及其原因</h2><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>节省页表的存储空间。</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p><strong>首先，举个例子：</strong><br>4GB的DDR空间，4KB的页大小，一个页表项大小为4B,总共需要4GB&#x2F;4K&#x3D;1M个页表项，如果每个进程都要产生并存储一个1Mx4B的PTE，就会占用不少内存空间。   </p><p>那么只要进程需要寻址4GB内存空间的能力，无论建立多少级的页表，最终都需要1Mx4B的空间，再加上多出来的几级页表存储空间只会更多，<strong>那么为什么会说多级页表可以节省内存空间呢？</strong>  </p><p>多级页表的好处是可以将PTE分散存储，而不是用连续的物理地址存储。<strong>即使只有一级的PTE页表，也可以根据程序运行的局部特性只在特定时刻生成一部分PTE页表，但关键不在于只生成一部分的PTE，而是只有一级页表的话需要连续物理地址空间，即使只生成一部分的PTE，这1Mx4B的地址空间也不能给别人用。</strong> 【这一原因也是很多文章没有说清楚的地方】  </p><p>另外多级页表还有一个优势，就是可以将那些不常用的低级页表swap out到硬盘中，当进程再次访问到该页表映射的物理内存时，内核将页表从硬盘中swap in到内存中。当然最顶层的PGD页表是必须常驻内存的。  </p><h3 id="总结起来多级页表能够节省内存空间的原因如下："><a href="#总结起来多级页表能够节省内存空间的原因如下：" class="headerlink" title="总结起来多级页表能够节省内存空间的原因如下："></a>总结起来多级页表能够节省内存空间的原因如下：</h3><p>（<strong>1）将页表变为非连续存储，同时可以只生成当前需要的一段页表</strong><br><strong>（2）可以将不常用页表swap到硬盘。</strong></p><h2 id="五、参考文章："><a href="#五、参考文章：" class="headerlink" title="五、参考文章："></a>五、参考文章：</h2><ul><li><a href="https://blog.csdn.net/cy413026/article/details/135861816?fromshare=blogdetail&sharetype=blogdetail&sharerId=135861816&sharerefer=PC&sharesource=weixin_62431476&sharefrom=from_link">内存管理(mmu&#x2F;smmu)&#x2F;内存分配原理&#x2F;多级页表</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网络模型与网络协议</title>
    <link href="/2025/03/04/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    <url>/2025/03/04/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="网络模型与网络协议"><a href="#网络模型与网络协议" class="headerlink" title="网络模型与网络协议"></a>网络模型与网络协议</h1><h2 id="一、网络模型"><a href="#一、网络模型" class="headerlink" title="一、网络模型"></a>一、网络模型</h2><p><img src="/../img/neworkModel/1.png" alt="1">      </p><ul><li><strong>OSI体系结构:</strong><br>概念清楚，理论也比较完整，但是它既复杂又不实用。   </li><li><strong>TCP&#x2F;IP体系结构:</strong><br>TCP&#x2F;IP是一个四层体系结构，得到了广泛的运用。   </li><li><strong>五层体系结构:</strong><br>为了方便学习，折中OSI体系结构和TCP&#x2F;IP体系结构，综合二者的优点，这样既简洁，又能将概念讲清楚。    </li><li><strong>TCP&#x2F;IP与OSI最大的不同在于：</strong><br>OSI是一个理论上的网络通信模型，而TCP&#x2F;IP则是实际广泛应用的网络协议。</li></ul><p><strong>封装和解封装过程：</strong><br><img src="/../img/neworkModel/2.png" alt="2"><br><img src="/../img/neworkModel/3.png" alt="3">        </p><h2 id="二、各层模型对应网路协议"><a href="#二、各层模型对应网路协议" class="headerlink" title="二、各层模型对应网路协议"></a>二、各层模型对应网路协议</h2><p>那么每一层是如何解析的呢？<br>比如我发送一个 10，如果我们用十进制解码那这个就是我们十进制的 10，如果是二进制解码那就是 1 和 0，但是如果我们提前规定好，1 表示“你” 0 表示“好”，那么我们达成这个协议，那么当传来 10 时你就会翻译为“你好”。<br>那么网络中也是一样的，每一层都会有不同的功能和不同的协议。   </p><table><thead><tr><th align="left">OSI七层网络模型</th><th align="center">TCP&#x2F;IP四层概念模型</th><th align="right">对应网络协议</th></tr></thead><tbody><tr><td align="left">应用层</td><td align="center">应用层</td><td align="right">HTTP、FTP、SMTP、TFTP、NFA、WAIS</td></tr><tr><td align="left">表示层</td><td align="center">应用层</td><td align="right">Telent、Rlogin、SNMP、Gopher</td></tr><tr><td align="left">会话层</td><td align="center">应用层</td><td align="right">SMTP、DNS</td></tr><tr><td align="left">传输层</td><td align="center">传输层</td><td align="right">TCP、UDP</td></tr><tr><td align="left">网络层</td><td align="center">网络层</td><td align="right">IP、ICMP、ARP、RARP、AKP、UUCP</td></tr><tr><td align="left">数据链路层</td><td align="center">网络接口层</td><td align="right">FDDI、Ethernet、Arpanet、PDN、SLIP、PPP</td></tr><tr><td align="left">物理层</td><td align="center">网络接口层</td><td align="right">IEEE802.1A等</td></tr></tbody></table><h2 id="三、五层网络体系结构概述"><a href="#三、五层网络体系结构概述" class="headerlink" title="三、五层网络体系结构概述"></a>三、五层网络体系结构概述</h2><p>五层网络体系结构各层的主要功能：</p><h3 id="应用层："><a href="#应用层：" class="headerlink" title="应用层："></a>应用层：</h3><p>应用层是网络协议的最高层，主要任务通过进程间的交互完成特定网络应用。应用层协议定义的是应用程序（进程）间通信和交互的规则。<br>对于不同的网络应用需要有不同的应用层协议，在互联网中的应用层协议很多，如域名系统DNS，支持万维网应用的HTTP协议，支持电子邮件的SMTP协议，等等。应用层交互的数据单元称为报文。   </p><h3 id="传输层："><a href="#传输层：" class="headerlink" title="传输层："></a>传输层：</h3><p>传输层负责为两台主机中的进程提供通信服务。该层主要有以下两种协议：   </p><h4 id="（1）TCP传输控制协议-Transmission-Control-Protocol"><a href="#（1）TCP传输控制协议-Transmission-Control-Protocol" class="headerlink" title="（1）TCP传输控制协议 (Transmission Control Protocol)"></a>（1）TCP传输控制协议 (Transmission Control Protocol)</h4><p>提供面向连接的、可靠的数据传输服务，数据传输的基本单位是报文段（segment）；    </p><h4 id="（2）UDP用户数据报协议-User-Datagram-Protocol"><a href="#（2）UDP用户数据报协议-User-Datagram-Protocol" class="headerlink" title="（2）UDP用户数据报协议 (User Datagram Protocol)"></a>（2）UDP用户数据报协议 (User Datagram Protocol)</h4><p>提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性，数据传输的基本单位是用户数据报。   </p><h3 id="网络层："><a href="#网络层：" class="headerlink" title="网络层："></a>网络层：</h3><p>网络层负责为分组网络中的不同主机提供通信服务，并通过选择合适的路由将数据传递到目标主机。在发送数据时，网络层把运输层产生的报文段或用户数据封装成分组或 包进行传送。<br>在TCP&#x2F;IP体系中，由于网络层使用IP协议，因此分组也叫IP数据报。   </p><h3 id="数据链路层："><a href="#数据链路层：" class="headerlink" title="数据链路层："></a>数据链路层：</h3><p>数据链路层通常简称为链路层。数据链路层在两个相邻节点传输数据时，将网络层交下来的IP数据报组装成帧，在两个相邻节点之间的链路上传送帧。   </p><h3 id="物理层："><a href="#物理层：" class="headerlink" title="物理层："></a>物理层：</h3><p>保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境。  </p><p>下图为应用进程的数据在各层之间的传递过程中所经历的变化的简单示意图：<br><img src="/../img/neworkModel/4.png" alt="4">        </p><h2 id="四、TCP协议"><a href="#四、TCP协议" class="headerlink" title="四、TCP协议"></a>四、TCP协议</h2><h3 id="什么是TCP协议？"><a href="#什么是TCP协议？" class="headerlink" title="什么是TCP协议？"></a>什么是TCP协议？</h3><p>TCP(传输控制协议, Transmission Control Protocol) 是一种面向连接的, 可靠的, 基于字节流的传输层通信协议, 广泛应用于互联网中。<br>它旨在提供可靠的端到端通信; 在双方进行通信之前, 必须先通过三次握手建立连接. TCP同时提供了一系列的机制来保证数据的可靠传输, 这些机制包括: 序列号, 确认应答, 重传控制, 流量控制和拥塞控制。  </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>锁</title>
    <link href="/2025/03/04/%E9%94%81/"/>
    <url>/2025/03/04/%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="一、锁的种类"><a href="#一、锁的种类" class="headerlink" title="一、锁的种类"></a>一、锁的种类</h2><p>在编程世界里，「锁」的种类五花八门，多种多样，每种锁的加锁开销以及应用场景也可能会不同。高并发的场景下，如果选对了合适的锁，则会大大提高系统的性能，否则性能会降低。所以，知道各种锁的开销，以及应用场景是很有必要的。  </p><h3 id="常见的几种锁"><a href="#常见的几种锁" class="headerlink" title="常见的几种锁"></a>常见的几种锁</h3><ul><li>互斥锁</li><li>自旋锁</li><li>读写锁</li><li>悲观锁</li><li>乐观锁</li></ul><h2 id="二、互斥锁、自旋锁相关背景"><a href="#二、互斥锁、自旋锁相关背景" class="headerlink" title="二、互斥锁、自旋锁相关背景"></a>二、互斥锁、自旋锁相关背景</h2><p>由于在多处理器环境中某些资源的有限性，有时需要互斥访问(mutual exclusion)，这时候就需要引入锁的概念，只有获取了锁的线程才能够对资源进行访问。  </p><p>由于<strong>多线程的核心是CPU的时间分片，所以同一时刻只能有一个线程获取到锁</strong>。那么就面临一个问题，那么没有获取到锁的线程应该怎么办？  </p><p><strong>通常有两种处理方式：</strong>   </p><ol><li><p>一种是没有获取到锁的线程就一直循环等待判断该资源是否已经释放锁，这种锁叫做自旋锁，它不用将线程阻塞(NON-BLOCKING)；</p></li><li><p>另一种处理方式就是把自己阻塞起来，等待重新调度请求，这种叫做互斥锁。</p></li></ol><h2 id="三、互斥锁（Mutex）"><a href="#三、互斥锁（Mutex）" class="headerlink" title="三、互斥锁（Mutex）"></a>三、互斥锁（Mutex）</h2><p>互斥锁是一种 <strong>「独占锁」</strong> —— 比如当线程 A 加锁成功后，此时互斥锁已经被线程 A 独占了，只要线程 A 没有释放手中的锁，线程 B 加锁就会失败，于是就会释放 CPU 让给其他线程，既然线程 B 释放掉了 CPU，自然线程 B 加锁的代码就会被阻塞。  </p><p>对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的。当加锁失败时，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒线程，当这个线程成功获取到锁后，于是就可以继续执行。  </p><p><img src="/../img/locks/mutex.png" alt="互斥锁mutex"></p><p>所以，互斥锁加锁失败时，会从用户态陷入到内核态，让内核来切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本（这个过程会有两次线程上下文切换的成本）。  </p><h3 id="1-两次上下文切换开销成本"><a href="#1-两次上下文切换开销成本" class="headerlink" title="1. 两次上下文切换开销成本"></a>1. 两次上下文切换开销成本</h3><ul><li>释放CPU资源（切出）：<br>   当线程加锁失败时，内核会把线程的状态从「运行」状态置为「睡眠」状态，并将 CPU 切换给其他线程运行；</li><li>唤醒并等待获取CPU（切入）：<br>   接着，当锁被释放时，之前「睡眠」状态的线程会变为「就绪」状态，然后内核会在合适的时间，把 CPU 切换给该线程运行。</li></ul><h3 id="2-线程的上下文切换的内容是什么？"><a href="#2-线程的上下文切换的内容是什么？" class="headerlink" title="2. 线程的上下文切换的内容是什么？"></a>2. 线程的上下文切换的内容是什么？</h3><p>当两个线程属于同一个进程时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些共享资源就保持不动，只需切换<strong>线程的私有数据、寄存器等不共享的数据</strong> 。  </p><h3 id="3-互斥锁的特点"><a href="#3-互斥锁的特点" class="headerlink" title="3. 互斥锁的特点"></a>3. 互斥锁的特点</h3><ul><li><strong>互斥性：</strong> 在任何时刻，只有一个线程可以持有互斥锁。  </li><li><strong>非忙等待：</strong> 当线程尝试获取一个已被其他线程持有的锁时，它会释放CPU进入阻塞状态，而不是进行忙等待（不断轮询锁的状态），从而节省CPU资源。  </li><li><strong>原子性：</strong> 锁的获取和释放操作是原子的，这意味着它们要么完全发生，要么完全不发生，不会出现中间状态。</li></ul><h3 id="4-互斥锁适用场景"><a href="#4-互斥锁适用场景" class="headerlink" title="4. 互斥锁适用场景"></a>4. 互斥锁适用场景</h3><p>上下切换的耗时大概在几十纳秒到几微秒之间，如果锁住的代码执行时间比较短，那可能上下文切换的时间都比锁住的代码执行时间还要长。<br>因此，如果能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁；否则使用互斥锁。  </p><h3 id="5-基于操作系统的原语"><a href="#5-基于操作系统的原语" class="headerlink" title="5. 基于操作系统的原语"></a>5. 基于操作系统的原语</h3><p>在许多操作系统中，互斥锁的实现依赖于内核提供的原语或者系统调用。这些原语可以确保在操作临界资源时的原子性和正确性。    </p><p>典型的原语包括：  </p><ul><li>信号量（semaphore）：信号量是一种用于控制并发访问的同步原语，可以用于实现互斥锁。</li><li>互斥量（mutex）：互斥量是一种特殊的信号量，它只允许一个线程访问临界资源。</li></ul><h2 id="四、自旋锁"><a href="#四、自旋锁" class="headerlink" title="四、自旋锁"></a>四、自旋锁</h2><h3 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h3><p>自旋锁是一种多线程同步机制，它使用一个共享的标志位来表示锁的状态——若标志位为true表示锁已被某个线程占用；若标志位为false，表示锁可用。   </p><p>当一个线程尝试获取自旋锁时，它会不断地检查这个标志位：  </p><ul><li>若标志位为false，则线程将设置标志位为true，表示自己占用了锁，并进入临界区。  </li><li>若标志位为true，则线程会在一个循环中不断检查锁的状态（自旋等待），直到锁被释放。<br>线程在自旋过程中不会被挂起，而是持续占用 CPU 资源进行忙等待。</li></ul><h3 id="2-加锁过程（原子操作）"><a href="#2-加锁过程（原子操作）" class="headerlink" title="2. 加锁过程（原子操作）"></a>2. 加锁过程（原子操作）</h3><p>自旋锁依赖于硬件提供的原子操作——CAS指令。<br>自旋锁通过 CPU 提供的 CAS 函数（Compare And Swap），<strong>在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换</strong> ，所以相比互斥锁会更快、开销更小。   </p><p>一般加锁的过程，包含两个步骤：  </p><ul><li>第一步，检查锁的状态，若锁空闲，则执行第二步； </li><li>第二步，将锁设置为当前线程持有；<br>CAS 函数将这两个步骤合并成一条硬件级指令，形成原子指令，保证这两个步骤不可分割，要么一次性执行完两个步骤，要么两个步骤都不执行。</li></ul><h3 id="3-自旋锁适用场景"><a href="#3-自旋锁适用场景" class="headerlink" title="3. 自旋锁适用场景"></a>3. 自旋锁适用场景</h3><p>若持有锁的线程能在短时间内释放锁资源，那么其余等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞状态，它们只需要等一等(自旋)，等到持有锁的线程释放锁之后即可获取，这样就避免了用户进程和内核切换的消耗。<br>自旋锁避免了操作系统进程调度和线程切换，所以自旋锁通常适用代码执行时间比较短的情况。由于这个原因，操作系统的内核经常使用自旋锁。<br>自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为<strong>自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗</strong> ，这些操作会导致线程发生两次上下文切换！    </p><h3 id="4-自旋锁不适用场景"><a href="#4-自旋锁不适用场景" class="headerlink" title="4. 自旋锁不适用场景"></a>4. 自旋锁不适用场景</h3><p>如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，占着 XX 不 XX，同时若还有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要 cpu 的线程又不能获取到 cpu，造成 cpu 的浪费。<br>如果被锁住的代码执行时间过长，自旋的线程会长时间占用 CPU 资源，所以自旋的时间和被锁住的代码执行的时间是成「正比」的关系，我们需要清楚的知道这一点。</p><h3 id="5-自旋锁的缺点"><a href="#5-自旋锁的缺点" class="headerlink" title="5. 自旋锁的缺点"></a>5. 自旋锁的缺点</h3><p>如果长时间上锁的话，自旋锁会非常耗费性能，它阻止了其他线程的运行和调度。线程持有锁的时间越长，则持有该锁的线程将被 OS调度程序中断的风险越大。如果发生中断情况，那么其他线程将保持旋转状态(反复尝试获取锁)，而持有该锁的线程并不打算释放锁，这样导致的是结果是无限期推迟，直到持有锁的线程可以完成并释放它为止。</p><h3 id="6-解决方案"><a href="#6-解决方案" class="headerlink" title="6. 解决方案"></a>6. 解决方案</h3><p>解决上面这种情况一个很好的方式是给自旋锁设定一个自旋时间，等时间一到立即释放自旋锁。<br>自旋锁的目的是占着CPU资源不进行释放，等到获取锁立即进行处理。但是如何去选择自旋时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用 CPU 资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要！<br>JDK在1.6 引入了适应性自旋锁，适应性自旋锁意味着自旋时间不是固定的了，而是由前一次在同一个锁上的自旋时间以及锁拥有的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间。</p><h2 id="五、互斥锁与自旋锁总结比较"><a href="#五、互斥锁与自旋锁总结比较" class="headerlink" title="五、互斥锁与自旋锁总结比较"></a>五、互斥锁与自旋锁总结比较</h2><h3 id="1-共同点"><a href="#1-共同点" class="headerlink" title="1. 共同点"></a>1. 共同点</h3><p>都是用于实现多线程同步的机制，确保临界资源的互斥访问。<br>都可以通过原子操作来保证线程安全。  </p><h3 id="2-不同点"><a href="#2-不同点" class="headerlink" title="2. 不同点"></a>2. 不同点</h3><p>实现原理不同：互斥锁依赖于操作系统提供的原语或系统调用，而自旋锁依赖于硬件提供的原子操作。<br>阻塞方式不同：互斥锁会导致线程阻塞和唤醒，而自旋锁会在循环中等待。<br>实现层面不同：自旋锁与互斥锁使用层面比较相似，但实现层面上完全不同：当加锁失败时，互斥锁用「线程切换」来应对，自旋锁则用「忙等待」来应对。<br>适用场景不同：互斥锁适用于长期占用临界资源的情况，而自旋锁适用于短期占用临界资源的情况。    </p><h3 id="3-阻塞-vs-自旋等待"><a href="#3-阻塞-vs-自旋等待" class="headerlink" title="3. 阻塞 vs 自旋等待"></a>3. 阻塞 vs 自旋等待</h3><p>互斥锁在获取锁时会导致线程阻塞，线程会被放入阻塞队列中，并在锁释放时被唤醒。这会引起线程上下文切换的开销。<br>自旋锁在获取锁时会循环检查锁的状态，直到获取到锁为止，期间线程会一直占用CPU资源，但不会进入阻塞状态，也不会加入到阻塞队列中。   </p><h3 id="4-开销"><a href="#4-开销" class="headerlink" title="4. 开销"></a>4. 开销</h3><p>由于互斥锁涉及到线程的阻塞和唤醒，它的开销相对较高。在高并发场景下，频繁的线程切换会导致性能下降。<br>自旋锁在获取锁时不会引起线程的阻塞和切换，因此在低竞争和短期占用临界资源的情况下，自旋锁的开销可能更低。   </p><h2 id="六、读写锁"><a href="#六、读写锁" class="headerlink" title="六、读写锁"></a>六、读写锁</h2><p>读写锁——由「读锁」和「写锁」两部分构成，如果只读取共享资源用「读锁」加锁，如果要修改共享资源则用「写锁」加锁。所以，读写锁适用于能明确区分读操作和写操作的场景。  </p><h3 id="1-读写锁的工作原理"><a href="#1-读写锁的工作原理" class="headerlink" title="1. 读写锁的工作原理"></a>1. 读写锁的工作原理</h3><p>当「写锁」未被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为「读锁」是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据。<br>但是，一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞。<br>「写锁」是独占锁，因为任何时刻只能有一个线程持有写锁，类似互斥锁和自旋锁；而「读锁」是共享锁，因为读锁可以被多个线程同时持有。<br>可以发现，读写锁在读多写少的场景，能发挥出优势。   </p><h3 id="2-「读优先锁」"><a href="#2-「读优先锁」" class="headerlink" title="2. 「读优先锁」"></a>2. 「读优先锁」</h3><p>读优先锁期望的是，读锁能被更多的线程持有，以便提高读线程的并发性。<br>工作方式：<br>当读线程 A 先持有了读锁，写线程 B 在获取写锁时就会被阻塞，并且在B阻塞过程中，后续来的读线程 C 仍然可以成功获取读锁，最后直到读线程 A 和 C 释放读锁后，写线程 B 才可以成功获取写锁。<br>如下图所示：<br><img src="/../img/locks/readFirst.png" alt="读优先锁"></p><h3 id="3-「写优先锁」"><a href="#3-「写优先锁」" class="headerlink" title="3. 「写优先锁」"></a>3. 「写优先锁」</h3><p>写优先锁是优先服务写线程。<br>工作方式：<br>当读线程 A 先持有了读锁，写线程 B 在获取写锁的时就会被阻塞，并且在B阻塞过程中，后续来的读线程 C 获取读锁时会失败，于是读线程 C 将被阻塞在获取读锁的操作，这样只要读线程 A 释放读锁后，写线程 B 就可以成功获取写锁。<br>如下图所示：<br><img src="/../img/locks/writeFirst.png" alt="写优先锁"><br>读优先锁对读线程并发性更好，但也不是没有问题——   </p><ul><li>如果一直有读线程获取读锁，那么写线程将永远获取不到写锁，这就造成了写线程「饥饿」的现象。   </li><li>写优先锁可以保证写线程不会饿死，但是如果一直有写线程获取写锁，读线程也会被「饿死」。<br>既然不管优先读锁还是写锁，对方都可能会出现饿死问题，那么我们就不偏袒任何一方，搞个「公平读写锁」。</li></ul><h3 id="4-「公平读写锁」"><a href="#4-「公平读写锁」" class="headerlink" title="4. 「公平读写锁」"></a>4. 「公平读写锁」</h3><p>比较简单的一种方式是用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现「饥饿」的现象。<br>互斥锁和自旋锁都是最基本的锁，读写锁可以根据场景来选择这两种锁其中的一个进行实现。</p><h2 id="七、乐观锁与悲观锁"><a href="#七、乐观锁与悲观锁" class="headerlink" title="七、乐观锁与悲观锁"></a>七、乐观锁与悲观锁</h2><h3 id="1-悲观锁"><a href="#1-悲观锁" class="headerlink" title="1. 悲观锁"></a>1. 悲观锁</h3><p>互斥锁、自旋锁、读写锁，都是属于悲观锁。<br>悲观锁做事比较悲观，<strong>悲观锁认为多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁</strong> 。  </p><h3 id="2-乐观锁（也叫无锁编程）"><a href="#2-乐观锁（也叫无锁编程）" class="headerlink" title="2. 乐观锁（也叫无锁编程）"></a>2. 乐观锁（也叫无锁编程）</h3><p>相反的，乐观锁做事比较乐观，它假定冲突的概率很低。若多线程同时修改共享资源的概率比较低，就可以采用乐观锁。<br><strong>乐观锁工作方式：</strong><br>先修改完共享资源，再验证这段时间内有没有发生冲突，若没有其他线程在修改资源，那么操作完成；若发现有其他线程已经修改过这个资源，则放弃本次操作。<br>放弃后如何重试，这跟业务场景息息相关，虽然重试的成本很高，但是冲突的概率足够低的话，还是可以接受的。可见，乐观锁的心态是，不管三七二十一，先改了资源再说。另外，可以发现<strong>乐观锁全程并没有加锁，所以它也叫无锁编程</strong> 。<br>乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以<strong>只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁</strong> 。</p><h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><h3 id="1-互斥锁"><a href="#1-互斥锁" class="headerlink" title="1. 互斥锁"></a>1. 互斥锁</h3><p>开发过程中，最常见的就是互斥锁了，互斥锁加锁失败时，会用「线程切换」来应对，当加锁失败的线程再次加锁成功后的这一过程，会有两次线程上下文切换的成本，性能损耗比较大。  </p><h3 id="2-自旋锁"><a href="#2-自旋锁" class="headerlink" title="2. 自旋锁"></a>2. 自旋锁</h3><p>如果我们明确知道被锁住的代码的执行时间很短，那我们应该选择开销比较小的自旋锁，因为自旋锁加锁失败时，并不会主动产生线程切换，而是一直忙等待，直到获取到锁，那么如果被锁住的代码执行时间很短，那这个忙等待的时间相对应也很短。   </p><h3 id="3-读写锁"><a href="#3-读写锁" class="headerlink" title="3. 读写锁"></a>3. 读写锁</h3><p>如果能区分读操作和写操作的场景，那读写锁就更合适了，它允许多个读线程可以同时持有读锁，提高了读的并发性。根据偏袒读方还是写方，可以分为读优先锁和写优先锁，读优先锁并发性很强，但是写线程会被饿死，而写优先锁会优先服务写线程，读线程也可能会被饿死，那为了避免饥饿的问题，于是就有了公平读写锁，它是用队列把请求锁的线程排队，并保证先入先出的原则来对线程加锁，这样便保证了某种线程不会被饿死，通用性也更好点。<br>互斥锁和自旋锁都是最基本的锁，读写锁可以根据场景来选择这两种锁其中的一个进行实现。  </p><h3 id="4-悲观锁"><a href="#4-悲观锁" class="headerlink" title="4. 悲观锁"></a>4. 悲观锁</h3><p>另外，互斥锁、自旋锁、读写锁都属于悲观锁，悲观锁认为并发访问共享资源时，冲突概率可能非常高，所以在访问共享资源前，都需要先加锁。  </p><h3 id="5-乐观锁（无锁编程）"><a href="#5-乐观锁（无锁编程）" class="headerlink" title="5. 乐观锁（无锁编程）"></a>5. 乐观锁（无锁编程）</h3><p>相反的，如果并发访问共享资源时，冲突概率非常低的话，就可以使用乐观锁，它的工作方式是，在访问共享资源时，不用先加锁，修改完共享资源后，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。<br>但是，一旦冲突概率上升，就不适合使用乐观锁了，因为它解决冲突的重试成本非常高。  </p><p>总的来说，不管使用的哪种锁，我们的加锁的代码范围应该尽可能的小，也就是加锁的粒度要小，这样执行速度会比较快。再来，使用上了合适的锁，就会快上加快了。</p><h2 id="九、参考文章"><a href="#九、参考文章" class="headerlink" title="九、参考文章"></a>九、参考文章</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/246114725">https://zhuanlan.zhihu.com/p/246114725</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>伙伴系统算法</title>
    <link href="/2025/03/04/%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    <url>/2025/03/04/%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="伙伴系统算法"><a href="#伙伴系统算法" class="headerlink" title="伙伴系统算法"></a>伙伴系统算法</h1><h2 id="伙伴系统概念"><a href="#伙伴系统概念" class="headerlink" title="伙伴系统概念"></a>伙伴系统概念</h2><p>伙伴系统是一种经典的内存管理方法。<br>Linux伙伴系统的引入为内核提供了一种用于分配一组连续的页而建立的一种高效的分配策略，并有效的解决了外碎片问题。  </p><h2 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h2><p>Linux中的内存管理的“页”大小为4KB。<br>把所有的空闲页分组为11个块链表，每个块链表分别包含（大小为1，2，4，8，16，32，64，128，256，512和1024个连续页框）的页块。最大可以申请1024个连续页，对应4MB大小的连续内存。每个页块的第一个页的物理地址是该块大小的整数倍。<br><img src="/../img/buddy/blocks.png" alt="块"></p><h2 id="伙伴系统内存分配与释放"><a href="#伙伴系统内存分配与释放" class="headerlink" title="伙伴系统内存分配与释放"></a>伙伴系统内存分配与释放</h2><h3 id="1-伙伴的概念"><a href="#1-伙伴的概念" class="headerlink" title="1. 伙伴的概念"></a>1. 伙伴的概念</h3><p>内核将满足以下条件的三个块称为伙伴：</p><ul><li>两个块具有相同的大小b。</li><li>它们的物理地址是连续的。</li><li>由同一个大块拆分出来（第一块的第一个页的物理地址是2*(2^b)的倍数）。<br><img src="/../img/buddy/buddyExample.png" alt="伙伴举例"></li></ul><h3 id="2-分裂与合并"><a href="#2-分裂与合并" class="headerlink" title="2. 分裂与合并"></a>2. 分裂与合并</h3><p><img src="/../img/buddy/separateAmerge.png" alt="分裂与合并"></p><h3 id="3-分配"><a href="#3-分配" class="headerlink" title="3. 分配"></a>3. 分配</h3><h4 id="分配过程："><a href="#分配过程：" class="headerlink" title="分配过程："></a>分配过程：</h4><p>①　在分配内存时，首先从空闲的内存中搜索比申请的内存大的最小的内存块。即当向内核请求分配 (2^(i-1)，2^i] 数目的页块时，按照2^i页块请求处理。   </p><p>②　如果这样的内存块存在，则将这块内存标记为“已用”，同时将该内存分配给应用程序。  </p><p>③　如果这样的内存不存在，则操作系统将寻找更大块的空闲内存，然后将这块内存平分成几部分，一部分返回给程序使用，另一部分作为空闲的内存块放到相应链表中。  </p><p><img src="/../img/buddy/fenpei.png" alt="分配过程"></p><h4 id="申请空间举例："><a href="#申请空间举例：" class="headerlink" title="申请空间举例："></a>申请空间举例：</h4><ul><li><strong>step1：</strong><br>假设要申请1M连续空间 4K * 256， 256 &#x3D; 2^8，我们就可以定位到下标为8的位置，看是否是空闲的。空闲则直接给他分配。</li><li><strong>step2：</strong><br>如果不空闲，就去512个页框也就是2M的链表中找，这个2M链表是否空闲。如果不空闲则继续向下找。</li><li><strong>step3：</strong><br>找到最后一个4M链表，如果没有空闲则分配失败返回错误。如果有空闲，则将其中1M分配给程序。剩余2M和1M分别放到对应的链表中。</li></ul><h3 id="4-释放"><a href="#4-释放" class="headerlink" title="4. 释放"></a>4. 释放</h3><h4 id="释放单页的内存时："><a href="#释放单页的内存时：" class="headerlink" title="释放单页的内存时："></a>释放单页的内存时：</h4><p>内核将其置于CPU高速缓存中，对很可能出现在cache的页，则放到“快表”（TLB）的列表中。在此过程中，内核先判断CPU高速缓存中的页数是否超过一定“阈值”，如果是，则将一批内存页还给伙伴系统，然后将该页添加到CPU高速缓存中。  </p><h4 id="释放多页内存时："><a href="#释放多页内存时：" class="headerlink" title="释放多页内存时："></a>释放多页内存时：</h4><p>前面的合并过程还没有体现出伙伴这个词的含义，伙伴这个词是在释放空间的时候体现出来的。     </p><ul><li>假设要释放一个大小为1M 的内存块（释放是申请的逆过程）：<br>1M &#x3D; 2^8 * 4KB，因此先检查对应所在链表8中该位置是否有该内存块的伙伴。<br>如果伙伴不存在，则直接将释放的块插入链表头。<br>如果所在链表中有伙伴存在，则将其伙伴从链表摘下，合并成一个大块，然后继续向后查找合并后的块在更大一级链表中是否有伙伴的存在，直至不能合并或者已经合并至最大块2^10为止。<br><img src="/../img/buddy/release.png" alt="释放过程"></li></ul><h2 id="查看buddy状态"><a href="#查看buddy状态" class="headerlink" title="查看buddy状态"></a>查看buddy状态</h2><h3 id="查看系统buddy状态信息（从左到右对应为0-11）："><a href="#查看系统buddy状态信息（从左到右对应为0-11）：" class="headerlink" title="查看系统buddy状态信息（从左到右对应为0~11）："></a>查看系统buddy状态信息（从左到右对应为0~11）：</h3><p><img src="/../img/buddy/systemBuddyCheck.png" alt="查看系统buddy状态信息"></p><h4 id="1-Node-0："><a href="#1-Node-0：" class="headerlink" title="1. Node 0："></a>1. Node 0：</h4><p>表示这是内存节点0的信息。在多核系统中，物理内存被分为几个节点，每个节点可以独立管理其内存。对于大多数小型和中型系统，通常只有一个节点（Node 0）。</p><h4 id="2-zone："><a href="#2-zone：" class="headerlink" title="2. zone："></a>2. zone：</h4><p>内存区域。<br>Linux 内存被分为几个区域（zone）。<br><strong>例如 ：</strong>  </p><ul><li>DMA（直接内存访问区域，用于需要物理地址连续性的设备） </li><li>DMA32（32位DMA区域，通常用于32位系统上的高端内存） </li><li>Normal（普通区域，用于常规内存分配）</li></ul><h2 id="结果分析："><a href="#结果分析：" class="headerlink" title="结果分析："></a>结果分析：</h2><h3 id="第一行："><a href="#第一行：" class="headerlink" title="第一行："></a>第一行：</h3><p><strong>Node 0, zone DMA：</strong><br>在这个区域中，存在多种大小的内存块，但数量相对较少，反映了 DMA 区域通常较小，且主要用于特定的硬件需求。</p><h3 id="第二行："><a href="#第二行：" class="headerlink" title="第二行："></a>第二行：</h3><p><strong>Node 0, zone DMA32：</strong><br>这个区域包含更多内存块，特别是较小的内存块（阶 0 到 4），这反映了系统在这一区域有较多的内存分配和释放活动，可能有一些碎片化。</p><h3 id="第三行："><a href="#第三行：" class="headerlink" title="第三行："></a>第三行：</h3><p><strong>Node 0, zone Normal：</strong><br>最大的区域，包含大量的内存块。随着阶的增加（即内存块大小的增加），可用的内存块数量急剧减少。说明大多数内存分配请求都是针对较小的内存块，而较大的连续内存块较为稀缺。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>VMware安装+Linux操作系统搭建记录(VMware16 + Ubuntu18.04-desktop)</title>
    <link href="/2025/03/04/VMware%E5%AE%89%E8%A3%85-Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95-VMware16-Ubuntu18-04-desktop/"/>
    <url>/2025/03/04/VMware%E5%AE%89%E8%A3%85-Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95-VMware16-Ubuntu18-04-desktop/</url>
    
    <content type="html"><![CDATA[<h1 id="VMware安装-Linux操作系统搭建记录-VMware16-Ubuntu18-04-desktop"><a href="#VMware安装-Linux操作系统搭建记录-VMware16-Ubuntu18-04-desktop" class="headerlink" title="VMware安装+Linux操作系统搭建记录(VMware16 + Ubuntu18.04-desktop)"></a>VMware安装+Linux操作系统搭建记录(VMware16 + Ubuntu18.04-desktop)</h1><h2 id="一、VMware虚拟机安装"><a href="#一、VMware虚拟机安装" class="headerlink" title="一、VMware虚拟机安装"></a>一、VMware虚拟机安装</h2><h3 id="1-下载vmware16安装包"><a href="#1-下载vmware16安装包" class="headerlink" title="1. 下载vmware16安装包"></a>1. 下载vmware16安装包</h3><p>网上很多资源，这次顺手存一下到自己的百度网盘里了。  </p><h3 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h3><p>（1）双击下载好的.exe程序开始安装  </p><p>（2）点击下一步<br><img src="/../img/vmUbuntu/1.png" alt="1">  </p><p>（3）勾选同意后下一步<br><img src="/../img/vmUbuntu/2.png" alt="2">  </p><p>（4）更改VMware的安装位置，不建议放系统盘（C），更改后点下一步（可以自己创建一个虚拟机安装目录存到对应目录下）<br><img src="/../img/vmUbuntu/3.png" alt="3">  </p><p>（5）不勾选直接下一步<br><img src="/../img/vmUbuntu/4.png" alt="4">  </p><p>（6）直接下一步<br><img src="/../img/vmUbuntu/5.png" alt="5">  </p><p>（7）点击安装<br><img src="/../img/vmUbuntu/6.png" alt="6">    </p><p>（8）等待安装完成（需要等待一会儿，尤其是在安装网络驱动时）<br><img src="/../img/vmUbuntu/7.png" alt="7">     </p><p>（9）点击许可证<br><img src="/../img/vmUbuntu/8.png" alt="8">   </p><p>（10）输入许可证——拷贝许可证到输入框里即可：<strong>ZF3R0-FHED2-M80TY-8QYGC-NPKYF</strong><br><img src="/../img/vmUbuntu/9.png" alt="9">     </p><p>（11）点击完成，这样就安装完成了<br><img src="/../img/vmUbuntu/10.png" alt="10">  </p><h2 id="二、安装Linux操作系统"><a href="#二、安装Linux操作系统" class="headerlink" title="二、安装Linux操作系统"></a>二、安装Linux操作系统</h2><h3 id="1-下载镜像源："><a href="#1-下载镜像源：" class="headerlink" title="1. 下载镜像源："></a>1. 下载镜像源：</h3><p>Linux操作系统有很多版本，本次搭建我使用的是从清华大学开源软件镜像网站<a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/18.04/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/18.04/</a>下载的Ubuntu18.04：<br><img src="/../img/vmUbuntu/11.png" alt="11">   </p><h3 id="2-开始安装操作系统"><a href="#2-开始安装操作系统" class="headerlink" title="2. 开始安装操作系统"></a>2. 开始安装操作系统</h3><p>（1）用管理员身份打开虚拟机软件<br><img src="/../img/vmUbuntu/12.png" alt="12"> </p><p>（2）点击创建虚拟机<br><img src="/../img/vmUbuntu/13.png" alt="13"> </p><p>（3）使用典型配置，点击下一步<br><img src="/../img/vmUbuntu/14.png" alt="14"> </p><p>（4）选择稍后安装操作系统，点击下一步<br><img src="/../img/vmUbuntu/15.png" alt="15"> </p><p>（5）选择linux，并选择ubuntu64位<br><img src="/../img/vmUbuntu/16.png" alt="16"> </p><p>（6）选择一个存放虚拟机的地方，不要选择VMware的安装目录（重新创建一个目录来存放）<br><img src="/../img/vmUbuntu/17.png" alt="17"> </p><p>（7）设定磁盘大小为40GB，并选择为单个文件<br><img src="/../img/vmUbuntu/18.png" alt="18"> </p><p>（8）点击完成<br><img src="/../img/vmUbuntu/19.png" alt="19"> </p><p>（9）在主机界面点击编辑虚拟机设置<br><img src="/../img/vmUbuntu/20.png" alt="20"> </p><p>（10）点击内存，设置虚拟机内存为4096MB<br><img src="/../img/vmUbuntu/21.png" alt="21"> </p><p>（11）点击处理器，设置处理器数量为2<br><img src="/../img/vmUbuntu/22.png" alt="22"> </p><p>（12）点击CD&#x2F;DVD ，勾选使用ISO映像文件，并选择下载好的镜像文件路径（参考教材中用的是Ubuntu20，选择自己的镜像文件就好了）<br><img src="/../img/vmUbuntu/23.png" alt="23"> </p><p>（13）点击USB控制器，点击移除<br><img src="/../img/vmUbuntu/24.png" alt="24"> </p><p>（14）点击打印机，点击移除，点击确定<br><img src="/../img/vmUbuntu/25.png" alt="25"> </p><h2 id="三、开启虚拟机并安装VMwareTools"><a href="#三、开启虚拟机并安装VMwareTools" class="headerlink" title="三、开启虚拟机并安装VMwareTools"></a>三、开启虚拟机并安装VMwareTools</h2><h3 id="1-开启此虚拟机"><a href="#1-开启此虚拟机" class="headerlink" title="1. 开启此虚拟机"></a>1. 开启此虚拟机</h3><p><img src="/../img/vmUbuntu/26.png" alt="26"> </p><p>等待校验完成<br><img src="/../img/vmUbuntu/27.png" alt="27"> </p><p>选择install ubuntu<br><img src="/../img/vmUbuntu/28.png" alt="28"> </p><p>选择英语键盘，然后continue<br><img src="/../img/vmUbuntu/29.png" alt="29"> </p><p>Normal installation，不勾选安装时更新，按下continue<br><img src="/../img/vmUbuntu/30.png" alt="30"> </p><p>直接点击Install Now<br><img src="/../img/vmUbuntu/31.png" alt="31"> </p><p>直接continue<br><img src="/../img/vmUbuntu/32.png" alt="32"> </p><p>选择地点为shanghai<br><img src="/../img/vmUbuntu/33.png" alt="33"> </p><p>设置用户名和密码<br><img src="/../img/vmUbuntu/34.png" alt="34"> </p><p>等待一会<br><img src="/../img/vmUbuntu/35.png" alt="35"> </p><p>直接Restart Now<br><img src="/../img/vmUbuntu/36.png" alt="36"> </p><p>当出现Please remove the installation medium, then press Enter时，按下快捷键ctrl+alt，将鼠标从虚拟机转换到主机。并点击虚拟机-&gt;设置<br><img src="/../img/vmUbuntu/37.png" alt="37"> </p><p>点击CD&#x2F;DVD 并勾选使用物理驱动器<br><img src="/../img/vmUbuntu/38.png" alt="38"> </p><p>若出现以下情况则选择“是”<br><img src="/../img/vmUbuntu/39.png" alt="39"> </p><p>再回到虚拟机中按Enter<br><img src="/../img/vmUbuntu/40.png" alt="40"> </p><p>点击自己账户，并输入账户密码<br><img src="/../img/vmUbuntu/41.png" alt="41"> </p><p>退出欢迎界面<br><img src="/../img/vmUbuntu/42.png" alt="42"> </p><p>暂时不更新，点击Remind Me Later<br><img src="/../img/vmUbuntu/43.png" alt="43"> </p><p>在屏幕中右键，点击Open in Terminal<br><img src="/../img/vmUbuntu/44.png" alt="44"> </p><p>输入ping -c 4 <a href="http://www.baidu.com,检查网络是否连通/">www.baidu.com，检查网络是否连通</a><br><img src="/../img/vmUbuntu/45.png" alt="45"> </p><h3 id="2-安装VMware-Tools"><a href="#2-安装VMware-Tools" class="headerlink" title="2. 安装VMware Tools"></a>2. 安装VMware Tools</h3><p><strong>背景：</strong><br>在Ubuntu 18.04安装完之后会发现此时的Ubuntu Desktop 并不能在VMware中全屏显示，不能自适应vm; 且无法实现主机到虚拟机的双向复制粘贴。  </p><p><strong>接下来是可以永久自适应vm的解决办法：</strong>  </p><ul><li>（1）首先在终端执行命令sudo apt-get update</li><li>（2）接下来安装vm-tools，在终端执行以下命令：<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo apt-<span class="hljs-built_in">get</span> install <span class="hljs-keyword">open</span>-<span class="hljs-keyword">vm</span>-tools<br>sudo apt-<span class="hljs-built_in">get</span> install <span class="hljs-keyword">open</span>-<span class="hljs-keyword">vm</span>-tools-desktop<br></code></pre></td></tr></table></figure>安装过程当中，除了输入yes确认外一直按enter键确定即可；</li></ul><p>（3）安装完成后，执行以下操作（见下图）：<br><img src="/../img/vmUbuntu/46.png" alt="46">   </p><p>（4）终端执行重启命令，此时就已经自适应了:   </p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">reboot</span><br></code></pre></td></tr></table></figure><h2 id="四、参考文章："><a href="#四、参考文章：" class="headerlink" title="四、参考文章："></a>四、参考文章：</h2><ul><li><a href="https://laoshisan.blog.csdn.net/article/details/121434777?fromshare=blogdetail&sharetype=blogdetail&sharerId=121434777&sharerefer=PC&sharesource=weixin_62431476&sharefrom=from_link">虚拟机安装ubuntu后屏幕无法自适应vm窗口大小</a></li></ul><h3 id="！！！！！特殊说明："><a href="#！！！！！特殊说明：" class="headerlink" title="！！！！！特殊说明："></a><strong>！！！！！特殊说明：</strong></h3><p>文档内容只是自己的学习记录，在前辈分享的教程以及网上找到的教程基础上完成的搭建，很多都是CV工程，包括截图偷懒不想回头重新截一次就CV了（知识的搬运工）。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>VMware16 + Ubuntu18.04-live-server搭建记录</title>
    <link href="/2025/03/04/VMware16-Ubuntu18-04-live-server%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/03/04/VMware16-Ubuntu18-04-live-server%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="VMware16-Ubuntu18-04-live-server搭建记录"><a href="#VMware16-Ubuntu18-04-live-server搭建记录" class="headerlink" title="VMware16 + Ubuntu18.04-live-server搭建记录"></a>VMware16 + Ubuntu18.04-live-server搭建记录</h1><p><strong>前言：</strong><br>之前VMware16已经安装好了，接下来直接进行Ubuntu18.04-live-server的安装。  </p><h2 id="1-下载镜像源"><a href="#1-下载镜像源" class="headerlink" title="1. 下载镜像源"></a>1. 下载镜像源</h2><p><a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/18.04/">清华大学开源软件镜像站https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/18.04/</a>  </p><h2 id="2-开始安装配置"><a href="#2-开始安装配置" class="headerlink" title="2. 开始安装配置"></a>2. 开始安装配置</h2><p>（1）点击“创建新的虚拟机”，弹出“新虚拟机向导页面”（如下），选择自定义（高级），下一步：<br><img src="/../img/vmUbuntu/47.png" alt="47">   </p><p>（2）下一步<br><img src="/../img/vmUbuntu/48.png" alt="48">   </p><p>（3）点击“稍后安装”，下一步<br><img src="/../img/vmUbuntu/49.png" alt="49">   </p><p>（4）选择“Linux”，版本选择“Ubuntu64位”，下一步<br><img src="/../img/vmUbuntu/50.png" alt="50">    </p><p>（5）命名虚拟机，与之前的desktop版本区分：<br><img src="/../img/vmUbuntu/51.png" alt="51">    </p><p>（6）处理器配置默认，下一步<br><img src="/../img/vmUbuntu/52.png" alt="52">   </p><p>（7）内存设置保持4096，下一步<br><img src="/../img/vmUbuntu/53.png" alt="53">            </p><p>（8）网络类型设置NAT模式（服务器版本可以选择使用桥接网络方便连接，桌面版一般选择NAT模式，但后续也可更改设置），下一步；<br><img src="/../img/vmUbuntu/54.png" alt="54">       </p><p>（9）“I&#x2F;O控制器类型”选择“LSI Logic”，下一步<br><img src="/../img/vmUbuntu/55.png" alt="55">      </p><p>（10）“选择磁盘类型”选择“SCSI”，下一步<br><img src="/../img/vmUbuntu/56.png" alt="56">      </p><p>（11）“选择磁盘” 选择“创建新虚拟磁盘”，下一步<br><img src="/../img/vmUbuntu/57.png" alt="57">  </p><p>（12）“指定磁盘容量”根据个人需求这只大小 先选择默认，下一步<br><img src="/../img/vmUbuntu/58.png" alt="58">     </p><p>（13）直接下一步（文件存放路径默认放在准备好的空文件夹，并无大碍）<br><img src="/../img/vmUbuntu/59.png" alt="59">  </p><p>（14）点击“自定义硬件”<br><img src="/../img/vmUbuntu/60.png" alt="60">    </p><p>（15）点击点击 “新CD&#x2F;DVD(SATA)”，然后点击“使用ISO映像文件”，接着浏览选择准备好的镜像文件<br><img src="/../img/vmUbuntu/61.png" alt="61">    </p><p>（16）然后点击关闭：<br><img src="/../img/vmUbuntu/62.png" alt="62">    </p><p>（17）点击完成，虚拟机就安装完成了！<br><img src="/../img/vmUbuntu/63.png" alt="63">    </p><p>（18）然后可以在虚拟机页面看到新的虚拟机<br><img src="/../img/vmUbuntu/64.png" alt="64">    </p><p>（19）开启虚拟机 Ubuntu-live-server18.04<br><img src="/../img/vmUbuntu/65.png" alt="65">    </p><p>（20）跳转到选择语言界面，通过上下键选择“English”<br><img src="/../img/vmUbuntu/66.png" alt="66">    </p><p>（21）这里页面要选择更新安装程序，通过上下键选择 “continue without updating”然后选择 Enter（回车）：<br><img src="/../img/vmUbuntu/67.png" alt="67">    </p><p>（22）然后选择Done<br><img src="/../img/vmUbuntu/68.png" alt="68">    </p><p>（23）这里是网络连接说明，创建虚拟机选择NAT 系统默认分配好了IP 不用修改，直接默认，上下键 “Done”， Enter （回车）：<br><img src="/../img/vmUbuntu/69.png" alt="69">    </p><p>（24）这里选择代理服务器，刚才选择了NAT模式进行连接外网，所以可以默认空，上下键“Done”，Enter （回车）：<br><img src="/../img/vmUbuntu/70.png" alt="70">     </p><p>（25）这里选择镜像地址 （自动识别）默认值即可，上下键“Done”，回车确认：<br><img src="/../img/vmUbuntu/71.png" alt="71">     </p><p>（26）这里是存储配置 默认即可<br><img src="/../img/vmUbuntu/72.png" alt="72">     </p><p>（27）这里是自动分配存储配置， 默认即可，上下键“Done”，回车：<br><img src="/../img/vmUbuntu/73.png" alt="73">     </p><p>（28）这里是对磁盘整理安装前的提示，“Continue”，回车：<br><img src="/../img/vmUbuntu/74.png" alt="74">     </p><p>（29）设置自己的账户密码，设置完成后，选择“Done”，回车：<br><img src="/../img/vmUbuntu/75.png" alt="75">     </p><p>（30）作为服务器使用，安装ssh，先选择“No”跳过，后面自己安装<br><img src="/../img/vmUbuntu/76.png" alt="76">     </p><p>（31）先跳过<br><img src="/../img/vmUbuntu/77.png" alt="77">     </p><p>（32）等待安装完成<br><img src="/../img/vmUbuntu/78.png" alt="78">     </p><p>（33）完成，点击重启<br><img src="/../img/vmUbuntu/79.png" alt="79">     </p><p>（34）出现如下问题<br><img src="/../img/vmUbuntu/80.png" alt="80">   </p><p>（35）进入虚拟机设置，取消勾选“启动时连接”<br><img src="/../img/vmUbuntu/81.png" alt="81">   </p><p>（36）确认<br><img src="/../img/vmUbuntu/82.png" alt="82">   </p><p>（37）登录普通用户<br><img src="/../img/vmUbuntu/83.png" alt="83">   </p><p>（38）设置root用户密码<br><img src="/../img/vmUbuntu/84.png" alt="84">   </p><h2 id="3-安装VMware-Tools"><a href="#3-安装VMware-Tools" class="headerlink" title="3. 安装VMware Tools"></a>3. 安装VMware Tools</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo apt-<span class="hljs-built_in">get</span> install <span class="hljs-keyword">open</span>-<span class="hljs-keyword">vm</span>-tools<br></code></pre></td></tr></table></figure><p><img src="/../img/vmUbuntu/85.png" alt="85">   </p><p>更新安装包<br><img src="/../img/vmUbuntu/86.png" alt="86">   </p><h2 id="4-基本完成！"><a href="#4-基本完成！" class="headerlink" title="4. 基本完成！"></a>4. 基本完成！</h2><p>服务器版本安装后当作服务器使用，通过远程ssh连接使用（工具：MobaXterm）   </p><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h2><ul><li><a href="https://blog.csdn.net/weixin_64717288/article/details/127338136?fromshare=blogdetail&sharetype=blogdetail&sharerId=127338136&sharerefer=PC&sharesource=weixin_62431476&sharefrom=from_link">ubuntu 18.04 server安装（详细安装教程）</a>    </li><li><a href="https://blog.csdn.net/m0_47958289/article/details/117414891?fromshare=blogdetail&sharetype=blogdetail&sharerId=117414891&sharerefer=PC&sharesource=weixin_62431476&sharefrom=from_link">VMware安装Ubuntu18.04-Server图文教程</a>      </li><li><a href="https://blog.csdn.net/TianYanRen111/article/details/121434777">虚拟机安装ubuntu后屏幕无法自适应vm窗口大小</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Sphinx学习与使用记录（Windows）</title>
    <link href="/2025/03/04/Sphinx%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%EF%BC%88Windows%EF%BC%89/"/>
    <url>/2025/03/04/Sphinx%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%EF%BC%88Windows%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="Sphinx学习与使用记录（Windows）"><a href="#Sphinx学习与使用记录（Windows）" class="headerlink" title="Sphinx学习与使用记录（Windows）"></a>Sphinx学习与使用记录（Windows）</h1><h2 id="一、Sphinx"><a href="#一、Sphinx" class="headerlink" title="一、Sphinx"></a>一、Sphinx</h2><p>Sphinx 是一个文档生成工具，用于将一组 reStructuredText 源文件组织成一个文档（如：HTML、PDF），并自动生成交叉引用、索引等。<br>reStructuredText 是一种轻量级纯文本标记语言，也被简称为：RST 或 reST，以 .rst 为扩展名的文件。</p><h2 id="二、安装Sphinx"><a href="#二、安装Sphinx" class="headerlink" title="二、安装Sphinx"></a>二、安装Sphinx</h2><h3 id="1、安装Python和pip"><a href="#1、安装Python和pip" class="headerlink" title="1、安装Python和pip"></a>1、安装Python和pip</h3><p>进入官网下载Python3安装包，点击.exe文件按指引安装即可（自定义安装目录）。<br>python官网：<a href="https://www.python.org/">https://www.python.org/</a><br><img src="/../img/sphinxLearn/pythonExe.jpg" alt="Python安装包"></p><h3 id="2、安装Sphinx"><a href="#2、安装Sphinx" class="headerlink" title="2、安装Sphinx"></a>2、安装Sphinx</h3><p>打开命令提示符（cmd），输入如下命令 :  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install Sphinx<br></code></pre></td></tr></table></figure><h3 id="3、创建工作目录并创建sphinx项目"><a href="#3、创建工作目录并创建sphinx项目" class="headerlink" title="3、创建工作目录并创建sphinx项目"></a>3、创建工作目录并创建sphinx项目</h3><h4 id="创建工作目录："><a href="#创建工作目录：" class="headerlink" title="创建工作目录："></a>创建工作目录：</h4><p>在D盘目录下建立一个 sphinx 目录, 又在其中建立了一个 try1目录用于测试，例如 D:\sphinx\try1</p><h4 id="使用在本地创建sphinx项目"><a href="#使用在本地创建sphinx项目" class="headerlink" title="使用在本地创建sphinx项目:"></a>使用在本地创建sphinx项目:</h4><p>然后从此目录进入cmd并启动sphinx （执行sphin-quickstart）以创建并配置工程, 整个过程命令表示如下:<br><img src="/../img/sphinxLearn/sphinxProjectCreate.jpg" alt="创建sphinx项目"></p><h4 id="进入文档资源配置对话框："><a href="#进入文档资源配置对话框：" class="headerlink" title="进入文档资源配置对话框："></a>进入文档资源配置对话框：</h4><p>询问的第一项: 设置文档的根目录,由于现在处于根目录, 所以使用默认的当前目录, 即直接回车使用默认设置即可;<br>询问的第二项: 希望把构建的最终文档目录放在哪儿,是放在”source”里创建成”_build”, 即 try1&#x2F;source&#x2F;_build ,还是放在根目录里创建成”build”, 即 try1&#x2F;build , 选择分离方便管理,所以输入 y. 如下图所示:<br><img src="/../img/sphinxLearn/separation.jpg" alt="分离source和build目录"></p><h4 id="输入项目名、作者名、项目版本号："><a href="#输入项目名、作者名、项目版本号：" class="headerlink" title="输入项目名、作者名、项目版本号："></a>输入项目名、作者名、项目版本号：</h4><p><img src="/../img/sphinxLearn/givename.jpg" alt="输入名称"></p><h4 id="选择文档语言"><a href="#选择文档语言" class="headerlink" title="选择文档语言"></a>选择文档语言</h4><p>文档语言默认是en，若要选择中文则输入zh_CN（简体中文），对应config.py文件内：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">language</span> = <span class="hljs-string">&#x27;zh_CN&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="创建完成："><a href="#创建完成：" class="headerlink" title="创建完成："></a>创建完成：</h4><p><img src="/../img/sphinxLearn/finish.jpg" alt="完成创建项目"></p><p>项目创建后目录结构如下所示：<br><img src="/../img/sphinxLearn/structure.jpg" alt="项目目录结构"></p><p><strong>以下为各个文件的详细说明：</strong>  </p><p><strong>1.Makefile：</strong> 编译过代码的开发人员应该非常熟悉这个文件，如果不熟悉，那么可以将它看作是一个包含指令的文件，在使用 make 命令时，可以使用这些指令来构建文档输出。 </p><p><strong>2._build：</strong> 这是触发特定输出后用来存放所生成的文件的目录。  </p><p><strong>3._static：</strong> 所有不属于源代码（如图像）一部分的文件均存放于此处，稍后会在构建目录中将它们链接在一起。  </p><p><strong>4.conf.py：</strong> 这是一个 Python 文件，用于存放 Sphinx 的配置值，包括在终端执行 sphinx-quickstart 时选中的那些值。  </p><p><strong>5.index.rst：</strong> 文档项目的 root 目录。如果将文档划分为其他文件，该目录会连接这些文件。（index.rst 文件相当于文档的“目录树”或“目录根”）  </p><h4 id="利用make命令生成demo页面"><a href="#利用make命令生成demo页面" class="headerlink" title="利用make命令生成demo页面"></a>利用make命令生成demo页面</h4><p>回到project的主目录中，打开命令提示符并运行make html。<br><img src="/../img/sphinxLearn/make_html.jpg" alt="编译">  </p><p>生成完毕后，打开build&#x2F;html&#x2F;目录下的相应html文件，即可体验由Sphinx生成的静态页面。<br><img src="/../img/sphinxLearn/indexPage.jpg" alt="主页静态页面"> </p><h3 id="4、定义文档结构"><a href="#4、定义文档结构" class="headerlink" title="4、定义文档结构"></a>4、定义文档结构</h3><p>主文档index.rst的主要功能是被转换成欢迎页, 它包含一个目录表（ “table of contents tree”或者 toctree）。Sphinx 主要功能是使用 reStructuredText, 把许多文件组织成一份结构合理的文档。  </p><p>为文档新建内容文件，例如：test.md<br>可以在toctree下方添加文档列表<br><img src="/../img/sphinxLearn/index_fileStructure.jpg" alt="新建文件"> </p><p><strong>注意：</strong> 文档文件放在与index.rst同级目录下</p><h3 id="5、支持markdown文件、更改文档主题"><a href="#5、支持markdown文件、更改文档主题" class="headerlink" title="5、支持markdown文件、更改文档主题"></a>5、支持markdown文件、更改文档主题</h3><h4 id="安装第三方库"><a href="#安装第三方库" class="headerlink" title="安装第三方库"></a>安装第三方库</h4><p>Spinx本身不支持.md文件生成文档，需要我们使用第三方库recommonmark进行转换。 首先分别运行下列命令安装recommonmark与sphinx_rtd_theme库。  </p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> recommonmark  <br><br>pip <span class="hljs-keyword">install</span> sphinx_rtd_theme    <br></code></pre></td></tr></table></figure><h4 id="修改config-py配置"><a href="#修改config-py配置" class="headerlink" title="修改config.py配置"></a>修改config.py配置</h4><p>安装好之后，在conf.py中修改下列两个配置以配置对markdown的支持：  </p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs clean">#指定HTML主题<br>html_theme = <span class="hljs-string">&#x27;sphinx_rtd_theme&#x27;</span><br><br>#-- 指定源文件扩展名列表-----<br><span class="hljs-keyword">from</span> recommonmark.parser <span class="hljs-keyword">import</span> CommonMarkParser<br><span class="hljs-keyword">import</span> sphinx_rtd_theme<br>source_suffix = [<span class="hljs-string">&#x27;.rst&#x27;</span>, <span class="hljs-string">&#x27;.md&#x27;</span>, <span class="hljs-string">&#x27;.MD&#x27;</span>]<br><br><br>#-- 将.md类型源文件解析器设置为CommonMark----------<br>source_parsers = &#123;<br>    <span class="hljs-string">&#x27;.md&#x27;</span>: CommonMarkParser,<br>    <span class="hljs-string">&#x27;.MD&#x27;</span>: CommonMarkParser,<br>&#125;<br></code></pre></td></tr></table></figure><p>添加扩展recommonmark：  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 添加扩展</span><br>extensions = [<span class="hljs-string">&#x27;recommonmark&#x27;</span>]<br></code></pre></td></tr></table></figure><h4 id="编译生成文档："><a href="#编译生成文档：" class="headerlink" title="编译生成文档："></a>编译生成文档：</h4><p>在Sphinx项目所在的文件夹路径下运行命令’make html’生成文档.<br><img src="/../img/sphinxLearn/mt2.png" alt="make-html2"> </p><p>生成后的文档位于build&#x2F;html文件夹内，用浏览器打开index.html即可看到生成后的文档：<br><img src="/../img/sphinxLearn/indexPage2.jpg" alt="new-themePage"> </p><p>至此，sphinx安装及项目创建完成。</p><h4 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h4><ul><li><a href="https://blog.hszofficial.site/recommend/2020/11/27/%E4%BD%BF%E7%94%A8Sphinx%E5%86%99%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/">使用Sphinx写项目文档</a>  </li><li><a href="https://zhuanlan.zhihu.com/p/27544821">用Sphinx快速制作文档</a>  </li><li><a href="https://www.osgeo.cn/sphinx-note/sphinx-setup.html#google_vignette">安装与使用Sphinx</a>  </li><li><a href="https://blog.csdn.net/weixin_40511249/article/details/127448107">Sphinx 入门及常见问题</a>  </li><li><a href="https://markdown.com.cn/basic-syntax/">Markdown 基本语法</a> </li><li><a href="https://www.sphinx-doc.org/en/master/usage/configuration.html">Sphinx</a></li><li><a href="https://sphinx-chinese-tutorial.readthedocs.io/en/latest/index.html">Sphinx 入门教程</a></li></ul><h3 id="6、Doxygen安装"><a href="#6、Doxygen安装" class="headerlink" title="6、Doxygen安装"></a>6、Doxygen安装</h3><h4 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h4><p>进入<a href="https://www.doxygen.nl/download.html">doxygen官网</a> 找到Windows GUI版直接下载就好：<br><img src="/../img/sphinxLearn/doxygen.png" alt="doxygen官网"> </p><h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><p><a href="https://www.doxygen.nl/manual/doxygen_usage.html">Doxygen使用</a><br><a href="http://blog.sysu.tech/Tools/Doxygen%E5%85%A5%E9%97%A8%E6%8C%87%E5%8C%97/">Doxygen入门指北</a></p><h3 id="7、使用vscod编写markdown文件"><a href="#7、使用vscod编写markdown文件" class="headerlink" title="7、使用vscod编写markdown文件"></a>7、使用vscod编写markdown文件</h3><p>在vscode中安装markdown相关插件：<br><img src="/../img/sphinxLearn/Plug_markdown.jpg" alt="wscode"> </p><p>安装完成后，新建.md后缀文件即可开始编写markdown文件。</p><h3 id="8、在项目内创建新文件"><a href="#8、在项目内创建新文件" class="headerlink" title="8、在项目内创建新文件"></a>8、在项目内创建新文件</h3><p>在index.rst同级目录下新建.md文件并编写文件内容，编写完成后，修改index.rst文件 —— 在toctree部分添加新建的.md文件：<br><img src="/../img/sphinxLearn/modify_index_rst.jpg" alt="修改index.rst"> </p><p>再执行make html即可生成对应的html文件到build目录下。</p><h3 id="9、添加图片"><a href="#9、添加图片" class="headerlink" title="9、添加图片"></a>9、添加图片</h3><p>在source&#x2F;_static&#x2F;目录下创建一个images目录存放本地图片。</p><h2 id="三、支持markdown表格"><a href="#三、支持markdown表格" class="headerlink" title="三、支持markdown表格"></a>三、支持markdown表格</h2><h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h3><p>安装markdown语法规则编写表格，编译后Markdown表格无法渲染</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elixir">| <span class="hljs-title class_">Align</span> `left`   | center align |   <span class="hljs-title class_">Align</span> right |<br>| <span class="hljs-symbol">:-------------</span> | <span class="hljs-symbol">:----------</span>: | ------------: |<br>| `left`-aligned |   centered   | right-aligned |<br>| `左`对齐        |    中对齐     |         右对齐 |<br><br></code></pre></td></tr></table></figure><h3 id="2-可能的原因"><a href="#2-可能的原因" class="headerlink" title="2. 可能的原因"></a>2. 可能的原因</h3><h4 id="空行缺失导致表格解析失败"><a href="#空行缺失导致表格解析失败" class="headerlink" title="空行缺失导致表格解析失败"></a>空行缺失导致表格解析失败</h4><p>Markdown表格必须与上文内容隔开一个空行，否则解析器会将其识别为普通文本。</p><h4 id="recommonmark默认不支持GFM表格"><a href="#recommonmark默认不支持GFM表格" class="headerlink" title="recommonmark默认不支持GFM表格"></a>recommonmark默认不支持GFM表格</h4><p>recommonmark基于CommonMark规范，默认不完整支持GitHub Flavored Markdown（GFM）表格语法。需启用扩展（不推荐，建议改用myst-parser）：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vim">（<span class="hljs-number">1</span>）安装第三方扩展<br>pip install sphinx-markdown-tables<br><br>（<span class="hljs-number">2</span>）修改config.<span class="hljs-keyword">py</span>文件添加扩展<br># <span class="hljs-keyword">conf</span>.<span class="hljs-keyword">py</span><br>extensions = [<br>    <span class="hljs-string">&#x27;recommonmark&#x27;</span>,<br>    <span class="hljs-string">&#x27;sphinx_markdown_tables&#x27;</span>  <br>]<br></code></pre></td></tr></table></figure><h4 id="未正确配置Markdown解析器"><a href="#未正确配置Markdown解析器" class="headerlink" title="未正确配置Markdown解析器"></a>未正确配置Markdown解析器</h4><p>建议改用myst-parser替代recommonmark（更现代且维护活跃）：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># x修改config.py文件</span><br><span class="hljs-attr">extensions</span> = [<span class="hljs-string">&#x27;myst_parser&#x27;</span>]<br><span class="hljs-attr">source_suffix</span> = [<span class="hljs-string">&#x27;.rst&#x27;</span>, <span class="hljs-string">&#x27;.md&#x27;</span>,<span class="hljs-string">&#x27;.MD&#x27;</span>]<br><br><span class="hljs-comment"># 删除旧版recommonmark相关配置</span><br><span class="hljs-comment"># source_parsers = &#123;&#x27;.md&#x27;: CommonMarkParser,&#x27;.MD&#x27;: CommonMarkParser,&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Sourceinsight安装记录</title>
    <link href="/2025/03/04/Sourceinsight%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/03/04/Sourceinsight%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Sourceinsight安装记录"><a href="#Sourceinsight安装记录" class="headerlink" title="Sourceinsight安装记录"></a>Sourceinsight安装记录</h1><h2 id="一、下载安装包"><a href="#一、下载安装包" class="headerlink" title="一、下载安装包"></a>一、下载安装包</h2><p><a href="https://www.ddooo.com/softdown/197204.htm">下载安装包地址：https://www.ddooo.com/softdown/197204.htm</a><br><img src="/../img/sourceinsight/1.png" alt="1"></p><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><ol><li><p>点击.exe文件安装，并点击next<br><img src="/../img/sourceinsight/2.png" alt="2"></p></li><li><p>选择红框accept后点击Next<br><img src="/../img/sourceinsight/3.png" alt="3"></p></li><li><p>修改安装目录，OK确认后next<br><img src="/../img/sourceinsight/4.png" alt="4"></p></li><li><p>点击install<br><img src="/../img/sourceinsight/5.png" alt="5"></p></li><li><p>点击finish，安装完成<br><img src="/../img/sourceinsight/5.png" alt="5"></p></li></ol><h2 id="三、SourceInsight4-0绿化"><a href="#三、SourceInsight4-0绿化" class="headerlink" title="三、SourceInsight4.0绿化"></a>三、SourceInsight4.0绿化</h2><ol><li><p>复制解压路径下的msimg32.dll到安装文件夹中<br><img src="/../img/sourceinsight/7.png" alt="7"></p></li><li><p>在安装目录运行解压生成的si4_kgen_unis.exe文件，点击Generate<br><img src="/../img/sourceinsight/8.png" alt="8"><br><img src="/../img/sourceinsight/9.png" alt="9">   </p></li><li><p>弹出文件保存框，点击保存即可<br><img src="/../img/sourceinsight/10.png" alt="10">  </p></li><li><p>关闭该软件即可<br><img src="/../img/sourceinsight/11.png" alt="11">  </p></li><li><p>验证绿化是否成功（打开sourceinsight软件，有红框中的Activated就是安装并激活成功）<br><img src="/../img/sourceinsight/12.png" alt="12"></p></li></ol><h2 id="四、参考"><a href="#四、参考" class="headerlink" title="四、参考"></a>四、参考</h2><p><a href="https://blog.csdn.net/qq_36035382/article/details/126239044">最新SourceInsight 4.0.124下载及安装教程</a>    </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用Samba实现文件共享</title>
    <link href="/2025/03/04/%E4%BD%BF%E7%94%A8Samba%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/"/>
    <url>/2025/03/04/%E4%BD%BF%E7%94%A8Samba%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="Samba实现文件共享"><a href="#Samba实现文件共享" class="headerlink" title="Samba实现文件共享"></a>Samba实现文件共享</h1><h2 id="一、安装samba"><a href="#一、安装samba" class="headerlink" title="一、安装samba"></a>一、安装samba</h2><h3 id="1-更新系统，确保Ubuntu系统是最新的"><a href="#1-更新系统，确保Ubuntu系统是最新的" class="headerlink" title="1. 更新系统，确保Ubuntu系统是最新的"></a>1. 更新系统，确保Ubuntu系统是最新的</h3><p><img src="/../img/samba/1.png" alt="1">      </p><h3 id="2-开始安装"><a href="#2-开始安装" class="headerlink" title="2. 开始安装"></a>2. 开始安装</h3><p>执行安装命令：      </p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">sudo</span> apt install samba samba-<span class="hljs-meta">common</span>   <br></code></pre></td></tr></table></figure><p><img src="/../img/samba/2.png" alt="2">    </p><p>安装后提示忽略以下错误，先记录一下，防止后续出问题便于排查：<br><img src="/../img/samba/3.png" alt="3">    </p><p>查看samba安装状态：    </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">samba <span class="hljs-comment">--version   </span><br></code></pre></td></tr></table></figure><p><img src="/../img/samba/4.png" alt="4">     </p><p>切换目录查看:    </p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">//</span>切换工作目录到此处，并通过<span class="hljs-keyword">ls</span>命令检查目录下文件。  <br><span class="hljs-keyword">cd</span> <span class="hljs-string">/etc/samba/</span>    <br></code></pre></td></tr></table></figure><p><img src="/../img/samba/5.png" alt="5">    </p><h3 id="3-创建共享目录"><a href="#3-创建共享目录" class="headerlink" title="3.  创建共享目录"></a>3.  创建共享目录</h3><p>创建要用于共享的目录，并将其权限设置为777（任何访问者均有read,write,execute权限）    </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">mkdir</span> /home/winnie/shared<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chmod</span> -R 777 /home/winnie/shared<br><span class="hljs-built_in">ls</span> -alh<br></code></pre></td></tr></table></figure><p><img src="/../img/samba/6.png" alt="6">   </p><h3 id="4-创建samba用户并设置密码"><a href="#4-创建samba用户并设置密码" class="headerlink" title="4. 创建samba用户并设置密码"></a>4. 创建samba用户并设置密码</h3><h3 id="5-编辑samba配置文件"><a href="#5-编辑samba配置文件" class="headerlink" title="5. 编辑samba配置文件"></a>5. 编辑samba配置文件</h3><p>Samba 的配置文件位于 &#x2F;etc&#x2F;samba&#x2F;smb.conf。通过vim打开该文件（该文件对非管理员为read-only权限，应使用sudo或以root身份访问）  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /etc/samba/<br><span class="hljs-built_in">sudo</span> vim smb.conf<br></code></pre></td></tr></table></figure><p><img src="/../img/samba/7.png" alt="7">   </p><p>在文件尾部加上下列一段 （ <strong>注意替换为自己的用户名和共享目录路径</strong> ！）：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">[share]<br><span class="hljs-attribute">path</span> <span class="hljs-operator">=</span> /home/winnie/shared<br><span class="hljs-attribute">public</span> <span class="hljs-operator">=</span> yes<br><span class="hljs-attribute">browsable</span> <span class="hljs-operator">=</span> yes<br><span class="hljs-attribute">writable</span> <span class="hljs-operator">=</span> yes<br>valid users <span class="hljs-operator">=</span> winnie<br><span class="hljs-attribute">available</span> <span class="hljs-operator">=</span> yes<br></code></pre></td></tr></table></figure><p><img src="/../img/samba/8.png" alt="8">   </p><p>注意：<br><img src="/../img/samba/9.png" alt="9">   </p><h3 id="6-将用户添加到samba的管理系统"><a href="#6-将用户添加到samba的管理系统" class="headerlink" title="6. 将用户添加到samba的管理系统"></a>6. 将用户添加到samba的管理系统</h3><p>接下来要将用户添加到samba的管理系统中。<br>首先在&#x2F;etc&#x2F;samba目录下创建文件 smbpasswd：   </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">touch</span> /etc/samba/smbpasswd<br></code></pre></td></tr></table></figure><p><img src="/../img/samba/10.png" alt="10">   </p><p>然后将现有的 Linux 用户 winnie 添加到 Samba 的用户列表中，并设置该用户的 Samba 密码。设置成功后将会看到 Added user XXX的提示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> smbpasswd -a winnie<br></code></pre></td></tr></table></figure><p><img src="/../img/samba/11.png" alt="11">   </p><p>通过以下命令启用用户，确保该用户可以登录samba服务。(启动成功后会提示Enable Username)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> smbpasswd -e winnie<br></code></pre></td></tr></table></figure><p><img src="/../img/samba/12.png" alt="12">   </p><p>修改完配置文件后，通过以下命令重启samba服务：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> /etc/init.d/smbd restart<br></code></pre></td></tr></table></figure><p><img src="/../img/samba/13.png" alt="13">   </p><p>重启服务之后测试所配置的samba（执行命令“testparm”）：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">testparm</span><br></code></pre></td></tr></table></figure><p><img src="/../img/samba/14.png" alt="14">   </p><p>该命令会检查Samba配置文件语法以及逻辑上的错误，如果无错误将会显示我们的配置文件。<br>再通过smbclient的命令来再一步检查（#如果共享成功，则会要求键入密码）：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">smbclient <span class="hljs-punctuation">-</span>L <span class="hljs-comment">//localhost/shared</span><br></code></pre></td></tr></table></figure><p><img src="/../img/samba/15.png" alt="15">   </p><h3 id="7-打开Windows文件管理器输入-linux的IP地址"><a href="#7-打开Windows文件管理器输入-linux的IP地址" class="headerlink" title="7. 打开Windows文件管理器输入\linux的IP地址"></a>7. 打开Windows文件管理器输入\linux的IP地址</h3><p>如下：<br><img src="/../img/samba/16.png" alt="16">   </p><p>双击文件夹，输入网络凭据（也就是我们前面添加的用户和密码）进行访问。<br><img src="/../img/samba/17.png" alt="17">   </p><p>尝试把文件复制到共享文件夹shared当中后，验证一下：<br><img src="/../img/samba/18.png" alt="18">   </p><p>成功！！！</p><h2 id="二、参考"><a href="#二、参考" class="headerlink" title="二、参考"></a>二、参考</h2><ul><li><a href="https://blog.csdn.net/R6bandito/article/details/143080904">Linux与Windows文件共享:Samba的详细配置(Ubuntu)</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Markdown文件编译语法规则</title>
    <link href="/2025/03/04/Markdown%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99/"/>
    <url>/2025/03/04/Markdown%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="Markdown文件编译语法规则"><a href="#Markdown文件编译语法规则" class="headerlink" title="Markdown文件编译语法规则"></a>Markdown文件编译语法规则</h1><h2 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h2><p>这是一个二级标题。Markdown使用’#’来表示标题，’#’的数量表示标题的级别，一个’#’表示一级标题，两个’#’表示二级标题，以此类推。</p><h2 id="二、字体样式"><a href="#二、字体样式" class="headerlink" title="二、字体样式"></a>二、字体样式</h2><ul><li><strong>粗体</strong>：使用2个’*’或’_’包裹文本。</li><li><em>斜体</em>：使用一个’*’或’_’包裹文本。</li><li><em><strong>加粗斜体</strong></em>：使用3个’*’或’_’包裹文本。</li><li><del>删除线</del>：使用2个’~’包裹文本。</li></ul><h2 id="三、列表"><a href="#三、列表" class="headerlink" title="三、列表"></a>三、列表</h2><ul><li><p>无序列表：使用’-‘、’*’或’+’来表示无序列表，例如：</p><ul><li>项目一</li><li>项目二</li><li>项目三</li></ul></li><li><p>有序列表：使用数字加点来表示有序列表，例如：</p><ol><li>第一步</li><li>第二步</li><li>第三步</li></ol></li></ul><h2 id="四、链接和图片"><a href="#四、链接和图片" class="headerlink" title="四、链接和图片"></a>四、链接和图片</h2><ul><li>链接：使用<a href="https://cn.bing.com/">链接文本</a>来表示链接，例如 <a href="https://www.baidu.com/">点击这里访问百度</a></li><li>图片: 使用感叹号+中括号+小括号组合表示图片。</li></ul><h2 id="五、引用"><a href="#五、引用" class="headerlink" title="五、引用"></a>五、引用</h2><p>这是一段引用内容：</p><blockquote><p>桃李不言，下自成蹊。</p></blockquote><h2 id="六、代码块"><a href="#六、代码块" class="headerlink" title="六、代码块"></a>六、代码块</h2><ul><li>在Markdown中，代码块是通过在一行的开头添加<strong>三个反引号</strong>来定义的，并且这三个反引号需要独占一行，即它们前面和后面都不能有其他字符（包括空格和制表符）。</li><li>注意：代码块最后若没有紧接着三个反引号来结束这个代码块，Markdown解析器会继续将后续的内容视为代码块的一部分，直到它遇到另一个代码块的结束标记（如果有的话）或者文档的末尾。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="七、预览Markdown文档"><a href="#七、预览Markdown文档" class="headerlink" title="七、预览Markdown文档"></a>七、预览Markdown文档</h2><ol><li>在VSCode中，你以使用内置的预览功能来查看Markdown文件的效果。</li><li>按下Ctrl+Shift+V（Windows&#x2F;Linux）或Cmd+Shift+V（Mac）快捷键，或者在VSCode的菜单栏中点击“查看”-&gt;“预览”来打开预览窗口。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>doxygen学习与使用记录（Windows）</title>
    <link href="/2025/03/04/doxygen%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%EF%BC%88Windows%EF%BC%89/"/>
    <url>/2025/03/04/doxygen%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%EF%BC%88Windows%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="doxygen学习与使用记录（Windows）"><a href="#doxygen学习与使用记录（Windows）" class="headerlink" title="doxygen学习与使用记录（Windows）"></a>doxygen学习与使用记录（Windows）</h1><h2 id="一、doxygen介绍"><a href="#一、doxygen介绍" class="headerlink" title="一、doxygen介绍"></a>一、doxygen介绍</h2><p>Doxygen是一个强大的文档生成工具，能够从源代码中提取注释并生成多种格式的文档。Doxygen能够自动从代码中的注释生成API文档，支持多种编程语言（包括C、C++、java等）。开发者只需在代码中添加注释，就能轻松生成结构化的文档，提高开发效率。</p><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><p><strong>1. <a href="https://www.doxygen.nl/">doxygen官网</a></strong><br><img src="/../img/doxygenLearn/doxygen.png" alt="doxygen官网下载页">  </p><p><strong>2. 进入官网后，根据系统选择对应文件下载。</strong><br>下载完成后双击.exe文件进行安装，根据提示逐步安装即可。<br><img src="/../img/doxygenLearn/install_Doxy.jpg" alt="doxygen安装"></p><h2 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h2><p>接下来尝试使用sphinx + doxygen根据源代码自动生成文档。   </p><p>Doxygen 与 Sphinx 不能直接关联，即 Sphinx 不能直接使用 Doxygen 生成的内容来生成 Sphinx 文档，它还需要一个插件来做适配，Breathe 就是为了连接 Doxygen 与 Sphinx 而生。  </p><p>要将 Doxygen 和 Sphinx 结合使用来生成文档，通常需要通过 Doxygen 生成 XML 格式的文档，然后使用 Sphinx 的 breathe 扩展将 Doxygen 生成的 XML 文件集成到 Sphinx 文档中。  </p><h3 id="1-准备所需工具"><a href="#1-准备所需工具" class="headerlink" title="1. 准备所需工具"></a>1. 准备所需工具</h3><p>使用sphinx + doxygen根据源代码自动生成文档前，需要确保已经安装以下工具：  </p><ul><li>Sphinx：用于生成和管理文档。  </li><li>Doxygen：用于从源代码生成 XML 格式的文档。  </li><li>Breathe：breathe 是Sphinx 的一个扩展，用于将 Doxygen 生成的 XML 文档与 Sphinx 集成，它允许将 Doxygen 生成的 XML 输出转换为 Sphinx 文档格式，这对于包含 C++ 代码的文档特别有用。  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># breathe扩展安装命令</span><br>pip <span class="hljs-keyword">install</span> breathe<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-创建工作目录："><a href="#2-创建工作目录：" class="headerlink" title="2. 创建工作目录："></a>2. 创建工作目录：</h3><p>新建一个独立文件夹（如Test_Code），下含2个目录（doc_project、dp_code）分别存储文档项目、项目代码。</p><h3 id="3-创建sphinx项目："><a href="#3-创建sphinx项目：" class="headerlink" title="3. 创建sphinx项目："></a>3. 创建sphinx项目：</h3><p>在doc_project目录下创建文档项目（参考“Sphinx学习与使用记录”完成该步骤）</p><h3 id="4-生成-Doxygen-配置文件"><a href="#4-生成-Doxygen-配置文件" class="headerlink" title="4. 生成 Doxygen 配置文件"></a>4. 生成 Doxygen 配置文件</h3><p>在使用 Doxygen 之前，需要为项目生成一个配置文件 Doxyfile（Doxyfile为自定义配置文件名称）。这个文件定义了 Doxygen 如何处理源代码并生成文档。 </p><p>可以通过以下命令生成一个默认的配置文件，执行该命令后，它将在当前目录下生成一个名为 Doxyfile 的配置文件，之后可以根据需要编辑该文件来定制文档的生成。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">doxygen -<span class="hljs-selector-tag">g</span> Doxyfile<br></code></pre></td></tr></table></figure><h3 id="5-配置Doxygen-生成-XML-输出"><a href="#5-配置Doxygen-生成-XML-输出" class="headerlink" title="5. 配置Doxygen 生成 XML 输出"></a>5. 配置Doxygen 生成 XML 输出</h3><p>Doxygen的配置是通过Doxyfile完成的。<br>打开Doxyfile文件，并根据需要按照Doxygen的文档和示例配置文件中提供的选项进行配置。</p><p><strong>1. INPUT —— 输入文件配置：</strong><br>INPUT标记用于指定包含记录源文件的文件和&#x2F;或目录。该标记可以指定需要doxygen自动生成文档的源文件的目录文件名（如 myfile.cpp）或 目录（如 &#x2F;usr&#x2F;src&#x2F;myproject），使用空格分隔文件或目录。 <strong>注意：</strong> 如果此标记为空，则搜索当前目录。  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">例：<br><span class="hljs-comment"># 指定源代码文件目录</span><br>INPUT       =    ..<span class="hljs-regexp">/../</span>dp_code<br></code></pre></td></tr></table></figure><p><strong>2. OUTPUT_DIRECTORY —— 输出目录配置：</strong><br>OUTPUT_DIRECTORY 标记用于指定文档输出的目录，即指定生成的文档将写入的（相对或绝对）路径。<br>如果输入了相对路径，则它将相对于启动 Doxygen 的位置。如果留空，则将使用当前目录。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">例:</span><br><span class="hljs-comment"># 指定生成的文档输出到build/doxygen目录</span><br>OUTPUT_DIRECTORY        =   build/doxygen<br></code></pre></td></tr></table></figure><p><strong>3. GENERATE_HTML —— 生成 HTML 文档：</strong><br>GENERATE_HTML 标记控制是否生成 HTML 格式的文档，若该标签设置为YES，Doxygen将生成HTML输出。默认值为 YES。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 若不需要生成HMTL文件，可将该标记设置为NO</span><br><span class="hljs-attr">GENERATE_HTML</span>       =   <span class="hljs-literal">YES</span><br></code></pre></td></tr></table></figure><p><strong>4. GENERATE_LATEX —— 生成 LaTex 文档：</strong><br>GENERATE_LATEX：控制是否生成 LaTeX 格式的文档，若该标签设置为YES，Doxygen将生成LaTeX输出。默认值为 YES。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 若不需要生成LATEX文件，可将该标记设置为NO</span><br><span class="hljs-attr">GENERATE_LATEX</span>       =   <span class="hljs-literal">YES</span><br></code></pre></td></tr></table></figure><p><strong>5. GENERATE_XML——生成 XML 文档：</strong><br>如果 GENERATE_XML 标签设置为 YES，Doxygen 将生成一个 XML 文件，该文件捕获代码的结构（包括所有文档）。默认值为：NO。  </p><p><strong>要将 Doxygen 和 Sphinx 结合使用来生成文档，通常需要通过 Doxygen 生成 XML 格式的文档，然后使用 Sphinx 的 breathe 扩展将 Doxygen 生成的 XML 文件集成到 Sphinx 文档中。</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 需要生成LATEX文件，将该标记设置为YES</span><br><span class="hljs-attr">GENERATE_LATEX</span>       =   <span class="hljs-literal">YES</span><br></code></pre></td></tr></table></figure><p><strong>6. OUTPUT_DIRECTORY —— 设置doxygen文档输出目录</strong><br>OUTPUT_DIRECTORY标记用来设置doxygen根据源代码文件自动生成文档的文档输出路径。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">OUTPUT_DIRECTORY</span>        = build/doxygen<br></code></pre></td></tr></table></figure><p><strong>7. INPUT_ENCODING——设置源文件编码：</strong><br>如果源代码文件是某种特定的编码（如 GB2312），可以设置该标签。此标签可用于指定 Doxygen 解析的源文件的字符编码。Doxygen 在内部使用 UTF-8 编码。Doxygen 使用 libiconv（或 libc 内置的 iconv）进行转码。参阅 libiconv 文档（<a href="https://www.gnu.org/software/libiconv/%EF%BC%89%E4%BB%A5%E8%8E%B7%E5%8F%96%E5%8F%AF%E8%83%BD%E7%9A%84%E7%BC%96%E7%A0%81%E5%88%97%E8%A1%A8%E3%80%82%E9%BB%98%E8%AE%A4%E5%80%BC%E4%B8%BA%EF%BC%9AUTF-8%E3%80%82">https://www.gnu.org/software/libiconv/）以获取可能的编码列表。默认值为：UTF-8。</a></p><p><strong>8. DOXYFILE_ENCODING——设置配置文件编码：</strong><br>此标记指定配置文件中所有字符使用的编码。默认值为 UTF-8，这也是此标记第一次出现之前所有文本使用的编码。</p><p><strong>9. EXCLUDE——忽略特定文件：</strong><br>EXCLUDE标记指定需要排除的文件或目录。该标记可用于指定应从 INPUT 源文件中排除的文件和&#x2F;或目录。这样就可以轻松地排除INPUT指定根目录的目录树中排除子目录。<br><strong>注意：相对路径是相对于运行 Doxygen 的目录而言的。</strong></p><p><strong>10. PROJECT_NAME：项目名称。</strong><br>PROJECT_NAME 标记是一个单词（或由双引号括起来的单词序列，除非您使用 Doxywizard），用于标识生成文档的项目。此名称用于大多数生成页面的标题和其他一些地方。默认值为：My project。</p><p><strong>11. PROJECT_NUMBER：项目版本号。</strong><br>#PROJECT_NUMBER 标签可用于输入项目或修订编号。这对于存档生成的文档或使用某些版本控制系统来说可能很方便。</p><p>配置完成后，保存并关闭Doxyfile文件。</p><h3 id="6-运行-Doxygen-生成-XML-文件"><a href="#6-运行-Doxygen-生成-XML-文件" class="headerlink" title="6. 运行 Doxygen 生成 XML 文件"></a>6. 运行 Doxygen 生成 XML 文件</h3><p>使用以下命令运行 Doxygen，根据 Doxyfile 配置生成 XML 输出文件：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">doxygen Doxyfile</span><br></code></pre></td></tr></table></figure><p>这会生成一个包含 XML 文档的目录（build&#x2F;doxygen），其中的 index.xml 文件即为 Doxygen 生成的 XML 文件。</p><h3 id="7-配置-Sphinx-项目"><a href="#7-配置-Sphinx-项目" class="headerlink" title="7. 配置 Sphinx 项目"></a>7. 配置 Sphinx 项目</h3><p>接下来，需要设置 Sphinx 来处理 Doxygen 生成的 XML 文件。</p><h4 id="配置-Sphinx-使用-breathe："><a href="#配置-Sphinx-使用-breathe：" class="headerlink" title="配置 Sphinx 使用 breathe："></a>配置 Sphinx 使用 breathe：</h4><ol><li><p>编辑 conf.py 文件，添加 breathe 扩展并配置 Doxygen XML 路径。在 extensions 列表中，添加 breathe 扩展：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment">#添加扩展</span><br><span class="hljs-attr">extensions</span> =[<span class="hljs-string">&#x27;recommonmark&#x27;</span>,<span class="hljs-string">&#x27;breathe&#x27;</span>]<br></code></pre></td></tr></table></figure></li><li><p>配置 breathe_projects，指定 Doxygen 生成的 XML 文件所在的路径：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment">#指定 Doxygen 生成的 XML 文件的输出路径</span><br>breathe_projects=&#123;<br><span class="hljs-string">&quot;myproject&quot;</span>:<span class="hljs-string">&quot;../build/doxygen/xml&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>配置 breathe_default_project，指定sphinx默认使用的Doxygen项目名称：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta"># 指定 Sphinx 默认使用的 Doxygen 项目名称</span><br>breathe <span class="hljs-literal">default</span> project =<span class="hljs-string">&quot;myproject&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>配置 breathe_domain_by_extension，指定所有 .h 文件按 C 语言域解析</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 所有 .h 文件按 C 语言域解析</span><br><span class="hljs-attr">breathe_domain_by_extension</span> = &#123;<span class="hljs-string">&quot;h&quot;</span> : <span class="hljs-string">&quot;c&quot;</span>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="8-编写doxygen风格代码注释"><a href="#8-编写doxygen风格代码注释" class="headerlink" title="8. 编写doxygen风格代码注释"></a>8. 编写doxygen风格代码注释</h3><p>Doxygen通过解析源代码中的注释来生成文档。因此，在编写代码时，需要添加适当的注释。  </p><h4 id="利用VSCode编写"><a href="#利用VSCode编写" class="headerlink" title="利用VSCode编写"></a>利用VSCode编写</h4><p>通过使用vscode编写doxygen风格注释——需要安装Doxygen相关插件：“Doxygen Documentation Generator”  、“Doxygen”  </p><p>成功安装插件后，键盘输入&#x2F;**回车即可自动生成doxygen风格注释。<br>在注释中，使用Doxygen的特殊标记（如@brief、@param、@return等）来描述代码的功能、参数和返回值等信息。</p><h3 id="9-新建-rst文件"><a href="#9-新建-rst文件" class="headerlink" title="9. 新建.rst文件"></a>9. 新建.rst文件</h3><p>最后，我们需要做的就是 doxygen 生成的 xml 文档集成到sphinx文档项目中。  </p><h4 id="1-在source目录下新建目录并在该目录下新建-index-rst-文件，并按照breathe扩展语法编辑-index-rst-文件，比如"><a href="#1-在source目录下新建目录并在该目录下新建-index-rst-文件，并按照breathe扩展语法编辑-index-rst-文件，比如" class="headerlink" title="1. 在source目录下新建目录并在该目录下新建 index.rst 文件，并按照breathe扩展语法编辑 index.rst 文件，比如:"></a>1. 在source目录下新建目录并在该目录下新建 index.rst 文件，并按照breathe扩展语法编辑 index.rst 文件，比如:</h4><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">我的API</span><br><span class="hljs-section">=============</span><br><br><span class="hljs-section">doxygen文档 myproject</span><br><span class="hljs-section">------------------------------------</span><br><span class="hljs-bullet">.. </span>doxygenindex::<br><span class="hljs-code">   :project: myproject</span><br><br><span class="hljs-section">源代码引用</span><br><span class="hljs-section">------------------------------------</span><br><br><span class="hljs-bullet">.. </span>literalinclude:: ../../../dp_code/thread.c<br><span class="hljs-code">   :language: c</span><br><br><br></code></pre></td></tr></table></figure><h4 id="2-可以添加以下内容来包含-Doxygen-生成的文档："><a href="#2-可以添加以下内容来包含-Doxygen-生成的文档：" class="headerlink" title="2. 可以添加以下内容来包含 Doxygen 生成的文档："></a>2. 可以添加以下内容来包含 Doxygen 生成的文档：</h4><p>（<strong>1）在index.rst中，使用Breathe指令批量导入doxygen项目所有内容：</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">doxygen文档 myproject</span><br><span class="hljs-section">------------------------------------</span><br><br><span class="hljs-bullet">.. </span>doxygenindex::<br><span class="hljs-code">   :project: myproject</span><br></code></pre></td></tr></table></figure><p><strong>（2）导入相应的文件生成的文档</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">sp.h</span><br><span class="hljs-section">----</span><br><br><span class="hljs-bullet">.. </span>doxygenfile:: sp.h<br></code></pre></td></tr></table></figure><p><strong>(3)使用 reStructuredText（reST）语法来引用源文件内容</strong><br>添加引用后，Sphinx 就会在生成文档时将 thread.c 文件的内容包含进来，并且 :language: c 告诉 Sphinx 文件是 C 语言代码，适当高亮语法。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">源代码引用</span><br><span class="hljs-section">------------------------------------</span><br><br><span class="hljs-bullet">.. </span>literalinclude:: ../../../dp_code/thread.c<br><span class="hljs-code">   :language: c</span><br></code></pre></td></tr></table></figure><h3 id="10-修改index-rst文件"><a href="#10-修改index-rst文件" class="headerlink" title="10. 修改index.rst文件"></a>10. 修改index.rst文件</h3><p>将新建的DX&#x2F;index.rst文件加入到sphinx项目的index.rst文件中。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">学习Doxygen使用记录</span><br><span class="hljs-section">======================================================</span><br><br><span class="hljs-bullet">.. </span>toctree::<br><span class="hljs-code">   :maxdepth: 2</span><br><span class="hljs-code">   :caption: Contents:</span><br><br><span class="hljs-code">   DX/index.rst</span><br></code></pre></td></tr></table></figure><h3 id="11-编译运行"><a href="#11-编译运行" class="headerlink" title="11. 编译运行"></a>11. 编译运行</h3><p>编译运行并打开index.html文件，生成文档如下：<br><img src="/../img/doxygenLearn/doxyAndsphinx.png" alt="doxygen自动生成文档效果"></p><h2 id="五、参考文章"><a href="#五、参考文章" class="headerlink" title="五、参考文章"></a>五、参考文章</h2><ul><li><a href="https://cloud.baidu.com/article/3266820">使用Doxygen创建代码文档</a>  </li><li><a href="https://promisechen.github.io/doc_guide/howto.html">如何用sphinx+reST编写文档</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Beyond Compare安装记录</title>
    <link href="/2025/03/04/Beyond-Compare%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/03/04/Beyond-Compare%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Beyond-Compare安装记录"><a href="#Beyond-Compare安装记录" class="headerlink" title="Beyond Compare安装记录"></a>Beyond Compare安装记录</h1><h2 id="一、下载安装包"><a href="#一、下载安装包" class="headerlink" title="一、下载安装包"></a>一、下载安装包</h2><p>下载地址：链接：<a href="https://pan.baidu.com/s/1srfC8Eg2P2BlK-CmpcW_uQ">https://pan.baidu.com/s/1srfC8Eg2P2BlK-CmpcW_uQ</a><br>提取码：l31m<br><img src="/../img/beyondCompare/1.png" alt="1">   </p><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><p>右击以管理员身份运行，傻瓜式安装，安装路径目录可以自定义，安装中选择为所有用户安装，安装完成运行软件， 找到 帮助——输入秘钥 打开<br>选择为所有用户安装，下一步：<br><img src="/../img/beyondCompare/2.png" alt="2">  </p><p>接受协议，下一步：<br><img src="/../img/beyondCompare/3.png" alt="3">  </p><p>选择安装位置，磁盘容量足够则直接下一步：<br><img src="/../img/beyondCompare/4.png" alt="4">  </p><p>下一步<br><img src="/../img/beyondCompare/5.png" alt="5">  </p><p>安装<br><img src="/../img/beyondCompare/6.png" alt="6"><br><img src="/../img/beyondCompare/7.png" alt="7">  </p><p>安装完成，运行程序：<br><img src="/../img/beyondCompare/8.png" alt="8">   </p><p>点击“注册-输入您的版本4的授权密钥”<br><img src="/../imgs/beyondCompare/9.png" alt="9">   </p><p>打开注册码文件：<br><img src="/../img/beyondCompare/10.png" alt="10">    </p><p>将密钥复制进去即可：<br><img src="/../img/beyondCompare/11.png" alt="11">  </p><p>点击确定，会弹出谢谢注册成功的会话框，找到 “帮助——关于beyondcompare” 详见下图：<br><img src="/../img/beyondCompare/12.png" alt="12">   </p><p>破解成功！</p><h2 id="三、参考："><a href="#三、参考：" class="headerlink" title="三、参考："></a>三、参考：</h2><ul><li><a href="https://blog.csdn.net/sinat_39684057/article/details/98053227">代码比较工具Beyond Compare 4</a></li><li><a href="https://blog.csdn.net/m0_57532432/article/details/140713629">【Beyond Compare】Beyond Compare下载、安装与使用详细教程</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Github+hexo搭建博客详细记录</title>
    <link href="/2024/11/05/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/11/05/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p><strong>全部搭建过程参考文章：</strong><a href="https://blog.csdn.net/yaorongke/article/details/119089190"><strong>https://blog.csdn.net/yaorongke/article/details/119089190</strong></a></p><p>SSH设置：<a href="https://github.com/pengwenwu/skill-tree/blob/master/Hexo/hexo%20%2B%20github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B.md">https://github.com/pengwenwu/skill-tree/blob/master/Hexo/hexo%20%2B%20github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B.md</a></p><h3 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a><strong>一、准备工作</strong></h3><h4 id="1-注册GitHub账号"><a href="#1-注册GitHub账号" class="headerlink" title="1.   注册GitHub账号"></a><strong>1.</strong>   <strong>注册GitHub账号</strong></h4><p>首先需要有一个GitHub账号，没有的话到先到GitHub官网注册（<a href="https://github.com/%EF%BC%89%E3%80%82">https://github.com/）。</a></p><p>注册可参考GitHub申请账号教程<a href="https://blog.csdn.net/yaorongke/article/details/119086305">https://blog.csdn.net/yaorongke/article/details/119086305</a></p><h4 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2. 安装Git"></a><strong>2.</strong> <strong>安装Git</strong></h4><p>在自己电脑上安装好Git，hexo部署到GitHub时要用。参考 Git安装(网址：<a href="https://blog.csdn.net/yaorongke/article/details/119085413?fromshare=blogdetail&sharetype=blogdetail&sharerId=119085413&sharerefer=PC&sharesource=weixin_62431476&sharefrom=from_link">https://blog.csdn.net/yaorongke/article/details/119085413?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=119085413&amp;sharerefer=PC&amp;sharesource=weixin_62431476&amp;sharefrom=from_link</a>)</p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/image1.png" alt=" "></p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/image2.png" alt=" "></p><h4 id="3-安装NodeJS"><a href="#3-安装NodeJS" class="headerlink" title="3. 安装NodeJS"></a><strong>3.</strong> <strong>安装NodeJS</strong></h4><p>在自己电脑上安装好NodeJS，Hexo是基于NodeJS编写的，所以需要安装NodeJS和npm工具。可参考NodeJS安装及配置(Windows)——</p><p><a href="https://blog.csdn.net/yaorongke/article/details/119084295?fromshare=blogdetail&sharetype=blogdetail&sharerId=119084295&sharerefer=PC&sharesource=weixin_62431476&sharefrom=from_link">https://blog.csdn.net/yaorongke/article/details/119084295?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=119084295&amp;sharerefer=PC&amp;sharesource=weixin_62431476&amp;sharefrom=from_link</a></p><p>我的安装具体步骤：</p><h5 id="（1）下载安装包"><a href="#（1）下载安装包" class="headerlink" title="（1）下载安装包"></a><strong>（1）下载安装包</strong></h5><p>NodeJS官网下载地址：<a href="https://nodejs.org/zh-cn/download/">https://nodejs.org/zh-cn/download/</a></p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/image3.png" alt=" "><br>下载安装包后双击安装包开始安装，一路点击Next即可，安装完成后，msi格式的安装包会自动添加环境变量。</p><p>安装finish后打开cmd，执行命令node -v查看node版本</p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/image4.png" alt=" "></p><p>在安装node的同时也安装了npm，执行 npm -v 查看npm版本</p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/image5.png" alt=" "></p><p>成功查看后就安装完成可以正常使用了，参考文章内还有讲解修改全局包配置，但我不需要这个所以省略后半部分，有需要可访问步骤3的网址。</p><h3 id="二、创建仓库"><a href="#二、创建仓库" class="headerlink" title="二、创建仓库"></a><strong>二、创建仓库</strong></h3><p><strong>1.</strong> 在GitHub上<strong>创建一个新的代码仓库</strong>用于保存我们的网页。点击<strong>Your repositories</strong>，进入仓库页面。</p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/image6.png" alt=" "><br><strong>2.</strong> <strong>点击New</strong>按钮，进入仓库创建页面。</p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/7.png" alt=" "></p><p><strong>3.</strong> <strong>填写仓库名</strong>（必须与用户名一致），格式必须为&lt;用户名&gt;.github.io，然后点击Create repository。</p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/8.png" alt=" "></p><p> <strong>4.</strong> <strong>点击creating a new file</strong>创建一个新文件，作为我们网站的主页。</p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/9.png" alt=" "><br><strong>5.</strong> <strong>新文件的名字必须为index.html</strong>，内容先随便写一个简单的，填写之后点击Commit new file提交。</p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/10.png" alt=" "><br>填写内容示例如下：</p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/11.png" alt=" "><br><strong>6.</strong> 在仓库页面，从上方导航栏<strong>进入“Settings”-“Pages”</strong>,找到主页的地址，示例为 <a href="https://yaorongke.github.io/">https://yaorongke.github.io/</a></p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/12.png" alt=" "><br><strong>7.</strong> 接下来直接访问查询到的主页地址<a href="https://yaorongke.github.io/%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E4%B8%80%E4%B8%AA%E6%AF%94%E8%BE%83%E7%AE%80%E9%99%8B%E7%9A%84%E7%BD%91%E9%A1%B5%EF%BC%9A">https://yaorongke.github.io/，可以看到一个比较简陋的网页：</a></p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/13.png" alt=" "></p><h3 id="三、安装Hexo"><a href="#三、安装Hexo" class="headerlink" title="三、安装Hexo"></a><strong>三、安装Hexo</strong></h3><p>Hexo 是一个基于NodeJS的静态博客网站生成器，使用Hexo不需开发，只要进行一些必要的配置即可生成一个个性化的博客网站，非常方便。Hexo官网<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p><h4 id="1-安装hexo"><a href="#1-安装hexo" class="headerlink" title="1.   安装hexo"></a><strong>1.</strong>   <strong>安装hexo</strong></h4><p>注意，<strong>第一个坑来了！</strong>——自行创建一个WorkSpace-blog目录，在该目录下安装hexo，安装hexo命令以官网为准npm install hexo-cli -g，参考文章内的命令不知道为啥不可用，归结为坑（bushi）</p><p><code>npm install hexo-cli -g</code></p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/14.png" alt=" "></p><ol start="2"><li>安装成功后查看版本</li></ol><p><code>hexo -v</code></p><ol start="3"><li>创建一个项目 hexo-blog 并初始化，</li></ol><p><code>hexo init blog</code></p><p><code>cd blog</code></p><p><code>npm install</code></p><ol start="4"><li>本地启动</li></ol><p><code>hexo g</code></p><p><code>hexo server</code></p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/15.png" alt=" "><br>这里有个踩过的坑：</p><p>启动失败了，原因是<strong>4000端口被占用</strong>，使用hexo s -p 8080命令<strong>更换端口</strong>.( 启动时需要在hexo-blog目录下)以自己的目录为准。</p><p>​                 更换为8080端口即可成功启动                </p><p>​                 启动失败，4000端口被占用                </p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/16.png" alt=" "></p><h3 id="四、更换主题"><a href="#四、更换主题" class="headerlink" title="四、更换主题"></a><strong>四、更换主题</strong></h3><h4 id="1-下载Fluid主题"><a href="#1-下载Fluid主题" class="headerlink" title="1. 下载Fluid主题"></a><strong>1.</strong> 下载Fluid主题</h4><p>  进入<a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid官网</a>安装主题，<strong>点击“最新 release 版本”</strong>下滑找到<strong>“Assets”</strong>部分。</p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/17.png" alt=" "></p><p>下载压缩包并解压到 “hexo-blog” – “themes” 目录，并将解压出的文件夹<strong>重命名为 fluid</strong><br><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/18.png" alt=" "></p><h4 id="2-指定主题"><a href="#2-指定主题" class="headerlink" title="2.   指定主题"></a><strong>2.</strong>   <strong>指定主题</strong></h4><p>如下修改hexo-blog目录中的 _config.yml文件的them和language（用vscode软件打开hexo-blog目录会非常好修改，后续需要执行的命令行也可以直接在vscode终端执行）：</p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/19.png" alt=" "></p><p>我的vscode修改界面：<br><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/20.png" alt=" "></p><ol start="3"><li><h4 id="创建「关于页」"><a href="#创建「关于页」" class="headerlink" title="创建「关于页」"></a><strong>创建「关于页」</strong></h4></li></ol><p>首次使用主题的「关于页」需要<strong>手动创建</strong>：</p><p><code>hexo new page about</code></p><p>创建成功后，编辑博客目录下 &#x2F;source&#x2F;about&#x2F;index.md，<strong>添加 layout 属性</strong>。</p><p>修改后的文件示例如下：<br><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/21.png" alt=" "></p><h3 id="五、发布到GitHub-Pages"><a href="#五、发布到GitHub-Pages" class="headerlink" title="五、发布到GitHub Pages"></a><strong>五、发布到GitHub Pages</strong></h3><h4 id="1-安装hexo-deployer-git"><a href="#1-安装hexo-deployer-git" class="headerlink" title="1.   安装hexo-deployer-git"></a><strong>1.</strong>   <strong>安装hexo-deployer-git</strong></h4><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/22.png" alt=" "></p><h4 id="2-修改-hexo-blog目录下的config-yml，配置-GitHub-相关信息"><a href="#2-修改-hexo-blog目录下的config-yml，配置-GitHub-相关信息" class="headerlink" title="2.  修改 hexo-blog目录下的config.yml，配置 GitHub 相关信息"></a><strong>2.</strong>  <strong>修改 hexo-blog目录下的config.yml，配置 GitHub 相关信息</strong></h4><p>坑！</p><p>配置.yml文件时，<strong>注意空格！！！</strong>否则报错</p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/23.png" alt=" "></p><p>接下来两个推送方式：</p><p>（1）参考文章内（如下）的配置方式部署不知道为什么一直没成功，放弃了。。。。。<br><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/24.png" alt=" "></p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/25.png" alt=" "><br>这个问题暂时没解决，推送换了ssh连接</p><p>（2）换成ssh推送继续往下肝，这里开始参考开头提到的第二篇文章：[**<a href="https://github.com/pengwenwu/skill-tree/blob/master/Hexo/hexo%20%2B%20github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B.md**]">https://github.com/pengwenwu/skill-tree/blob/master/Hexo/hexo%20%2B%20github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B.md**]</a>(<a href="https://github.com/pengwenwu/skill-tree/blob/master/Hexo/hexo">https://github.com/pengwenwu/skill-tree/blob/master/Hexo/hexo</a> %2B github搭建个人博客教程.md)</p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/26.png" alt=" "><br><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/27.png" alt=" "><br>以上步骤非常清晰，浅提几个点：</p><p>l  一开始没有.ssh目录，执行了命令ssh-keygen -t rsa -C “my email”命令，这里我是在c:&#x2F;用户&#x2F;username&#x2F;目录下执行的，生成完成后用记事本打开id_ras.pub文件，然后Ctrl-A复制所有内容。</p><p>l  接下来的github-&gt;头像-&gt;Settings→SSH kyes→Add SSH key，粘贴复制的内容。对应图片放这里：<br><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/28.png" alt=" "></p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/29.png" alt=" "></p><p>l  最后的url配置的就是步骤二-7中的主页地址</p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/30.png" alt=" "></p><p>l  repo的内容在仓库页面-code-SSH可以直接复制<br><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/31.png" alt=" "></p><p>l  全部修改完配置保存后执行hexo g -d，部署完成后就可以打开主页：</p><p><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/32.png" alt=" "></p><h4 id="3-修改-default分支"><a href="#3-修改-default分支" class="headerlink" title="3.  修改 default分支"></a><strong>3.</strong>  <strong>修改 default分支</strong></h4><p>又是一个坑人的小可爱<br>一开始发布文章后在主页看不到文章————GitHub发布page默认是master分支，但现在主页展示的是main分支推送的文章，所以我们就把default切换为了master<br><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/image8.png" alt=" "></p><p>再附上之前My cute ie家族引路人 在9月份配置时记录下的其他注意事项和链接！<br>Jessie’s channel————<a href="https://chenjessiee.github.io/2024/09/12/%E6%9C%80%E8%BF%91%E7%9A%84%E6%89%93%E7%AE%97/">https://chenjessiee.github.io/2024/09/12/%E6%9C%80%E8%BF%91%E7%9A%84%E6%89%93%E7%AE%97/</a></p><ol><li>Node下载，注意看是否直接下载安装程序，压缩包还不会使用。</li><li>在npm运行，就是Node，下载好了cmd到folder，执行npm命令就行。</li><li>注意.ignore文件，否则上传一大堆。</li><li>github分支很重要，默认执行分支main，这就会出现部署到master分支，本地能成功执行hexo，但是github访问不到，去setting切换分支即可。</li><li>github pages没有实时更改内容是很正常的，发布前先<code>hexo s -p 8080</code>，本地执行没问题，先使用 <code>hexo clean</code> 清除本地缓存，然后<code>hexo g -d</code>提交。</li><li>新建文章很简单，<code>hexo new name</code> 即可。</li><li>发布照片时，要把生成的照片文件夹放到source下的img静态资源文件夹，养成良好习惯，放在post里面无法访问。</li><li>切换master为default时在setting内设置即可（苦苦回忆终于找到入口haha!）<br><img src="/img/Github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/image7.png" alt=" "></li></ol><h3 id="六、Hexo-博客上传步骤"><a href="#六、Hexo-博客上传步骤" class="headerlink" title="六、Hexo 博客上传步骤"></a><strong>六、Hexo 博客上传步骤</strong></h3><h4 id="1-创建新文章"><a href="#1-创建新文章" class="headerlink" title="1.创建新文章"></a>1.创建新文章</h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">//进入_posts目录</span><br>cd C:\MyGit\WorkSpace\blog\hexo-blog\<span class="hljs-keyword">source</span>\_posts<br><br><span class="hljs-comment">//创建新文章</span><br>hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;文章标题&quot;</span><br></code></pre></td></tr></table></figure><h4 id="2-进入博客根目录"><a href="#2-进入博客根目录" class="headerlink" title="2.进入博客根目录"></a>2.进入博客根目录</h4><p>打开终端（CMD&#x2F;PowerShell）或者 Git Bash，进入你的 Hexo 博客目录。例如：</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">cd <span class="hljs-name">C</span>:\MyGit\WorkSpace\blog\hexo-blog<br></code></pre></td></tr></table></figure><h4 id="3-生成静态文件"><a href="#3-生成静态文件" class="headerlink" title="3. 生成静态文件"></a>3. 生成静态文件</h4><p>Hexo 需要先将 Markdown 文件转换成 HTML 静态页面：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog">hexo clean  #如果想先清理旧文件先执行该命令<br>hexo g  # hexo <span class="hljs-keyword">generate</span> 的缩写<br></code></pre></td></tr></table></figure><h4 id="4-本地预览（可选）"><a href="#4-本地预览（可选）" class="headerlink" title="4. 本地预览（可选）"></a>4. 本地预览（可选）</h4><p>在发布之前，可以先在本地测试是否正常：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">hexo</span> s  <span class="hljs-comment"># hexo server 的缩写</span><br>hexo s -p <span class="hljs-number">5000</span>  <span class="hljs-comment">#指定端口号（处理4000冲突的情况）</span><br></code></pre></td></tr></table></figure><h4 id="5-部署到远程服务器（GitHub-Pages-Coding-其他）"><a href="#5-部署到远程服务器（GitHub-Pages-Coding-其他）" class="headerlink" title="5. 部署到远程服务器（GitHub Pages &#x2F; Coding &#x2F; 其他）"></a>5. 部署到远程服务器（GitHub Pages &#x2F; Coding &#x2F; 其他）</h4><p>之前已经配置好了 Hexo 的 deploy 相关信息（比如 GitHub Pages），直接运行：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">hexo</span> d  <span class="hljs-comment"># hexo deploy 的缩写</span><br></code></pre></td></tr></table></figure><p>以上是在把winnie引入ie家族的元老Jessie的技术支持下进行首次搭建配置时遇到各种的坑坑，开启blog也是在昨晚Cute girl Jessie向我发出邀请，今天捣鼓了一天，在Jessie的大力支持和帮助下发出了第一篇bolg，今天正式拥有自己的blog了！</p><p><strong>Winnie遇到Jessie大概就像两个小行星跨越好多光年后终于交汇到一起。</strong><br><strong>2024.10.26的下午是个晴天，写下这些恰好在能看见星星的夜晚，那就以这样的方式把她们的相遇写在秋天。</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/11/05/hello-world/"/>
    <url>/2024/11/05/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
